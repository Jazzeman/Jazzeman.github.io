<html>
    <head>
        <link rel="stylesheet" href="styles.css" type="text/css">
    </head>

    <body style="background-color: rgb(40, 40, 40);">
        <canvas id="c" width="1800" height="900"></canvas>
        <div id="fps-container"><span id="fps"></span> FPS</div>
        <div class="controls">
            <div class="section">
                <h3>About</h3>
                <p>Use WASD -keys to move around and use mouse while holding mousebutton to look around.</p>
                <p>Check out the <a href="https://github.com/jassenousiainen/webgl-raytracer">repository</a></p>
            </div>
            <div class="section">
                <h3>Rendering settings</h3>
                <label class='switch'>
                    <input type="checkbox" id="enableGI" checked>
                    <span class='slider'></span>
                    Indirect lighting
                </label>
                <br>
                <label class='switch'>
                    <input type="checkbox" id="enableRefGI">
                    <span class='slider'></span>
                    Indirect in mirrors
                </label>
                <br><br>
                number of indirect samples:
                <br>
                <div class="slider_container">
                    <input type="range" value="50" id="indirectsamples" min="1" max="100" oninput="this.nextElementSibling.value = this.value">
                    <output>50</output>
                </div>
                <br>
                number of direct samples:
                <br>
                <div class="slider_container">
                    <input type="range" list="tickmarks" value="9" id="shadowsamples" min="1" max="25" oninput="this.nextElementSibling.value = this.value">
                    <output>9</output>
                </div>
                <datalist id="tickmarks">
                    <option value="1" label="1"></option>
                    <option value="4" label="4"></option>
                    <option value="9" label="9"></option>
                    <option value="16" label="16"></option>
                    <option value="25" label="25"></option>
                </datalist>
                <br>
                reflection bounces:
                <br>
                <div class="slider_container">
                    <input type="range" value="3" id="reflectionbounces" min="0" max="5" step="1" oninput="this.nextElementSibling.value = this.value">
                    <output>3</output>
                </div>
            </div>
            <div class="section" id="lightcontrols">
                <h3>Lights</h3>
                <label class='switch'>
                    <input type="checkbox" id="arealightsenable" checked>
                    <span class='slider'></span>
                    Area lights on/off
                </label>
                <br><br>
                Attenuation:<br>
                <input type="range" min="0" max="10" step="0.01" value="1.5" id="quadratic" class="attenuation"> Quadratic
                <input type="range" min="0" max="10" step="0.01" value="0" id="linear" class="attenuation"> Linear
                <br>
            </div>
            <div class="section" id="planecontrols">
                <h3>Planes</h3>
                <input type="checkbox" id="planebacksides" checked> Intersect backsides
                <br><br>
            </div>
            <div class="section">
                <h3>Extras</h3>
                <input type="checkbox" id="enablemirrorworld"> Mirror world
                <br>
            </div>
        </div>

        <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
            precision highp float;
            uniform mat4 invprojview;
            uniform float near;
            uniform float far;
            
            out lowp vec3 origin;
            out lowp vec3 ray;
            
            void main() {
                // https://rauwendaal.net/2014/06/14/rendering-a-screen-covering-triangle-in-opengl/
                float x = -1.0 + float((gl_VertexID & 1) << 2);
                float y = -1.0 + float((gl_VertexID & 2) << 1);
                gl_Position = vec4(x, y, 0, 1);
                            
                // https://stackoverflow.com/a/52764898
                origin = (invprojview * vec4(x, y, -1.0, 1.0) * near).xyz;
                ray = (invprojview * vec4(vec2(x,y) * (far - near), far + near, far - near)).xyz;
            }
        </script>
        <!-- Fragment GLSL optimized with: https://zz85.github.io/glsl-optimizer/ -->
        <script id="fragment-shader-fast" type="x-shader/x-fragment">#version 300 es
precision mediump float;
float randomIncrement;
uniform float randomseed;
uniform highp int numLights;
uniform vec3 lightPos[2];
uniform vec2 lightSize[2];
uniform vec3 lightBrightness[2];
uniform vec2 lightSpot[2];
uniform highp int shadowSamples;
uniform float shadowDim;
uniform vec2 attenuationFactor;
uniform highp int numSpheres;
uniform vec3 sphereCenters[4];
uniform vec3 sphereColors[4];
uniform vec3 reflectiveColors[4];
uniform vec3 sphereSpecColors[4];
uniform float sphereRoughness[4];
uniform highp int numPlanes;
uniform float planeOffsets[6];
uniform vec3 planeNormals[6];
uniform vec3 planeColors[6];
uniform float planeSpecular[6];
uniform float planeRoughness[6];
uniform highp int rayBounces;
uniform vec3 ambientLight;
uniform bool enableGI;
uniform bool enableRefGI;
uniform highp int indirectSamples;
uniform bool enablePlaneBacksides;
uniform bool enablePlaneMirrors;
in lowp vec3 origin;
in lowp vec3 ray;
out lowp vec4 fragColor;
void main ()
{
  float roughness_1;
  vec3 reflectiveColor_2;
  vec3 specularColor_3;
  lowp vec3 diffuseColor_4;
  lowp vec3 pixelColor_5;
  lowp vec3 tmpvar_6;
  tmpvar_6 = normalize(ray);
  randomIncrement = randomseed;
  lowp vec3 ray_origin_7;
  ray_origin_7 = origin;
  lowp vec3 ray_direction_8;
  ray_direction_8 = tmpvar_6;
  lowp float t_hit_9;
  t_hit_9 = sqrt(dot (ray, ray));
  lowp vec3 position_10;
  lowp vec3 normal_11;
  lowp vec3 diffuseColor_12;
  diffuseColor_12 = diffuseColor_4;
  vec3 specularColor_13;
  specularColor_13 = specularColor_3;
  vec3 reflectiveColor_14;
  reflectiveColor_14 = reflectiveColor_2;
  float roughness_15;
  roughness_15 = roughness_1;
  bool intersectLight_16;
  intersectLight_16 = bool(1);
  highp int idx_19;
  highp int intersected_20;
  intersected_20 = 0;
  idx_19 = 0;
  for (highp int i_18 = 0; i_18 < numSpheres; i_18++) {
    lowp float t_hit_21;
    t_hit_21 = t_hit_9;
    bool tmpvar_22;
    lowp vec3 tmpvar_23;
    tmpvar_23 = (sphereCenters[i_18] - ray_origin_7);
    lowp float tmpvar_24;
    tmpvar_24 = dot (tmpvar_23, ray_direction_8);
    if ((tmpvar_24 < 0.0)) {
      tmpvar_22 = bool(0);
    } else {
      lowp float tmpvar_25;
      tmpvar_25 = (dot (tmpvar_23, tmpvar_23) - (tmpvar_24 * tmpvar_24));
      if ((tmpvar_25 > 0.64)) {
        tmpvar_22 = bool(0);
      } else {
        lowp float tmpvar_26;
        tmpvar_26 = sqrt((0.64 - tmpvar_25));
        lowp float tmpvar_27;
        tmpvar_27 = (tmpvar_24 - tmpvar_26);
        lowp float tmpvar_28;
        tmpvar_28 = (tmpvar_24 + tmpvar_26);
        lowp float tmpvar_29;
        if ((tmpvar_27 < 0.0)) {
          tmpvar_29 = tmpvar_28;
        } else {
          tmpvar_29 = tmpvar_27;
        };
        if (((tmpvar_29 < t_hit_9) && (tmpvar_29 > 0.0))) {
          t_hit_21 = tmpvar_29;
          tmpvar_22 = bool(1);
        } else {
          tmpvar_22 = bool(0);
        };
      };
    };
    t_hit_9 = t_hit_21;
    if (tmpvar_22) {
      idx_19 = i_18;
      intersected_20 = 1;
    };
  };
  for (highp int i_17 = 0; i_17 < numPlanes; i_17++) {
    lowp vec3 tmpvar_30;
    tmpvar_30 = planeNormals[i_17];
    bool tmpvar_31;
    if (enablePlaneBacksides) {
      tmpvar_31 = bool(1);
    } else {
      tmpvar_31 = (dot (ray_direction_8, tmpvar_30) < 0.0);
    };
    if (tmpvar_31) {
      lowp float t_hit_32;
      t_hit_32 = t_hit_9;
      bool tmpvar_33;
      tmpvar_33 = bool(1);
      bool tmpvar_34;
      lowp vec3 tmpvar_35;
      tmpvar_35 = (tmpvar_30 * planeOffsets[i_17]);
      lowp float tmpvar_36;
      tmpvar_36 = (((
        (tmpvar_35.x + tmpvar_35.y)
       + tmpvar_35.z) - dot (tmpvar_30, ray_origin_7)) / dot (tmpvar_30, ray_direction_8));
      if (((tmpvar_36 < t_hit_9) && (tmpvar_36 > 0.0))) {
        t_hit_32 = tmpvar_36;
        tmpvar_34 = bool(1);
        tmpvar_33 = bool(0);
      };
      if (tmpvar_33) {
        tmpvar_34 = bool(0);
        tmpvar_33 = bool(0);
      };
      t_hit_9 = t_hit_32;
      if (tmpvar_34) {
        normal_11 = tmpvar_30;
        idx_19 = i_17;
        intersected_20 = 2;
      };
    };
  };
  intersectLight_16 = bool(0);
  for (highp int i_37 = 0; i_37 < numLights; i_37++) {
    bool tmp_38;
    vec3 tmpvar_39;
    tmpvar_39 = lightPos[i_37];
    vec2 tmpvar_40;
    tmpvar_40 = lightSize[i_37];
    tmp_38 = bool(0);
    if (((tmpvar_40.x > 0.0) && (tmpvar_40.y > 0.0))) {
      lowp float t_hit_41;
      t_hit_41 = t_hit_9;
      bool tmpvar_42;
      tmpvar_42 = bool(1);
      bool tmpvar_43;
      vec3 tmpvar_44;
      tmpvar_44 = (vec3(0.0, 1.0, 0.0) * tmpvar_39.y);
      lowp float tmpvar_45;
      tmpvar_45 = (((
        (tmpvar_44.x + tmpvar_44.y)
       + tmpvar_44.z) - ray_origin_7.y) / ray_direction_8.y);
      if (((tmpvar_45 < t_hit_9) && (tmpvar_45 > 0.0))) {
        lowp vec3 tmpvar_46;
        tmpvar_46 = (ray_origin_7 + (ray_direction_8 * tmpvar_45));
        if ((((tmpvar_40.x + tmpvar_40.y) == 0.0) || ((
          ((tmpvar_46.x < (tmpvar_39.x + (tmpvar_40.x * 0.5))) && (tmpvar_46.x > (tmpvar_39.x - (tmpvar_40.x * 0.5))))
         && 
          (tmpvar_46.z < (tmpvar_39.z + (tmpvar_40.y * 0.5)))
        ) && (tmpvar_46.z > 
          (tmpvar_39.z - (tmpvar_40.y * 0.5))
        )))) {
          t_hit_41 = tmpvar_45;
          tmpvar_43 = bool(1);
          tmpvar_42 = bool(0);
        };
      };
      if (tmpvar_42) {
        tmpvar_43 = bool(0);
        tmpvar_42 = bool(0);
      };
      t_hit_9 = t_hit_41;
      tmp_38 = tmpvar_43;
    } else {
      lowp float t_hit_47;
      t_hit_47 = t_hit_9;
      bool tmpvar_48;
      lowp vec3 tmpvar_49;
      tmpvar_49 = (tmpvar_39 - ray_origin_7);
      lowp float tmpvar_50;
      tmpvar_50 = dot (tmpvar_49, ray_direction_8);
      if ((tmpvar_50 < 0.0)) {
        tmpvar_48 = bool(0);
      } else {
        lowp float tmpvar_51;
        tmpvar_51 = (dot (tmpvar_49, tmpvar_49) - (tmpvar_50 * tmpvar_50));
        if ((tmpvar_51 > 0.01)) {
          tmpvar_48 = bool(0);
        } else {
          lowp float tmpvar_52;
          tmpvar_52 = sqrt((0.01 - tmpvar_51));
          lowp float tmpvar_53;
          tmpvar_53 = (tmpvar_50 - tmpvar_52);
          lowp float tmpvar_54;
          tmpvar_54 = (tmpvar_50 + tmpvar_52);
          lowp float tmpvar_55;
          if ((tmpvar_53 < 0.0)) {
            tmpvar_55 = tmpvar_54;
          } else {
            tmpvar_55 = tmpvar_53;
          };
          if (((tmpvar_55 < t_hit_9) && (tmpvar_55 > 0.0))) {
            t_hit_47 = tmpvar_55;
            tmpvar_48 = bool(1);
          } else {
            tmpvar_48 = bool(0);
          };
        };
      };
      t_hit_9 = t_hit_47;
      tmp_38 = tmpvar_48;
    };
    if (tmp_38) {
      idx_19 = i_37;
      intersected_20 = 3;
    };
  };
  position_10 = (origin + (tmpvar_6 * t_hit_9));
  if ((intersected_20 == 1)) {
    diffuseColor_12 = sphereColors[idx_19];
    specularColor_13 = sphereSpecColors[idx_19];
    reflectiveColor_14 = reflectiveColors[idx_19];
    roughness_15 = sphereRoughness[idx_19];
    lowp vec3 tmpvar_56;
    tmpvar_56 = normalize((position_10 - sphereCenters[idx_19]));
    normal_11 = tmpvar_56;
    lowp float tmpvar_57;
    tmpvar_57 = dot (tmpvar_56, -(tmpvar_6));
    if ((tmpvar_57 < 0.0)) {
      normal_11 = -(tmpvar_56);
    };
  } else {
    if ((intersected_20 == 2)) {
      if (!(enablePlaneMirrors)) {
        diffuseColor_12 = planeColors[idx_19];
        specularColor_13 = vec3(planeSpecular[idx_19]);
        reflectiveColor_14 = vec3(0.0, 0.0, 0.0);
        roughness_15 = planeRoughness[idx_19];
      } else {
        diffuseColor_12 = (planeColors[idx_19] * 0.01);
        specularColor_13 = vec3(0.0, 0.0, 0.0);
        reflectiveColor_14 = planeColors[idx_19];
        roughness_15 = 1.0;
      };
      lowp float tmpvar_58;
      tmpvar_58 = dot (normal_11, -(tmpvar_6));
      if ((tmpvar_58 < 0.0)) {
        normal_11 = -(normal_11);
      };
    } else {
      if ((intersected_20 == 3)) {
        lowp float spot_falloff_59;
        spot_falloff_59 = 1.0;
        vec2 tmpvar_60;
        tmpvar_60 = lightSpot[idx_19];
        if ((tmpvar_60.x > 0.0)) {
          lowp float tmpvar_61;
          if ((tmpvar_6.y > tmpvar_60.x)) {
            tmpvar_61 = pow (tmpvar_6.y, tmpvar_60.y);
          } else {
            tmpvar_61 = 0.0;
          };
          spot_falloff_59 = tmpvar_61;
        };
        diffuseColor_12 = ((spot_falloff_59 * lightBrightness[idx_19]) * 0.2);
        intersectLight_16 = bool(1);
      };
    };
  };
  diffuseColor_4 = diffuseColor_12;
  specularColor_3 = specularColor_13;
  reflectiveColor_2 = reflectiveColor_14;
  roughness_1 = roughness_15;
  if (intersectLight_16) {
    lowp vec4 tmpvar_62;
    tmpvar_62.w = 1.0;
    tmpvar_62.xyz = diffuseColor_12;
    fragColor = tmpvar_62;
    return;
  };
  if (!(enableGI)) {
    pixelColor_5 = (pixelColor_5 + (ambientLight * diffuseColor_12));
  };
  lowp vec3 P_63;
  P_63 = position_10;
  lowp vec3 V_64;
  V_64 = tmpvar_6;
  lowp vec3 N_65;
  N_65 = normal_11;
  lowp vec3 diffuseColor_66;
  diffuseColor_66 = diffuseColor_12;
  vec3 specularColor_67;
  specularColor_67 = specularColor_13;
  lowp vec3 illuminationColor_69;
  for (highp int i_68 = 0; i_68 < numLights; i_68++) {
    highp int k_70;
    bool inShade_71;
    highp int areaShadowSamples_72;
    highp int testSamples_73;
    lowp vec3 light_sum_74;
    vec2 lightSpot_75;
    vec2 lightSize_76;
    vec3 lightBrightness_77;
    vec3 lightPos_78;
    lightPos_78 = lightPos[i_68];
    lightBrightness_77 = lightBrightness[i_68];
    vec2 tmpvar_79;
    tmpvar_79 = lightSize[i_68];
    lightSize_76 = tmpvar_79;
    lightSpot_75 = lightSpot[i_68];
    bool tmpvar_80;
    tmpvar_80 = ((tmpvar_79.x > 0.0) && (tmpvar_79.y > 0.0));
    highp int tmpvar_81;
    if (tmpvar_80) {
      tmpvar_81 = 5;
    } else {
      tmpvar_81 = 1;
    };
    testSamples_73 = tmpvar_81;
    areaShadowSamples_72 = 0;
    inShade_71 = bool(0);
    k_70 = 0;
    while (true) {
      vec3 testPos_82;
      if ((k_70 >= testSamples_73)) {
        break;
      };
      if (inShade_71) {
        break;
      };
      testPos_82 = lightPos_78;
      if ((k_70 == 1)) {
        testPos_82.x = (lightPos_78.x - (lightSize_76.x * 0.5));
        testPos_82.z = (lightPos_78.z - (lightSize_76.y * 0.5));
      } else {
        if ((k_70 == 2)) {
          testPos_82.x = (testPos_82.x + (lightSize_76.x * 0.5));
          testPos_82.z = (testPos_82.z + (lightSize_76.y * 0.5));
        } else {
          if ((k_70 == 3)) {
            testPos_82.x = (testPos_82.x + (lightSize_76.x * 0.5));
            testPos_82.z = (testPos_82.z - (lightSize_76.y * 0.5));
          } else {
            if ((k_70 == 4)) {
              testPos_82.x = (testPos_82.x - (lightSize_76.x * 0.5));
              testPos_82.z = (testPos_82.z + (lightSize_76.y * 0.5));
            };
          };
        };
      };
      lowp vec3 L_83;
      lowp vec3 incidentIntensity_84;
      lowp float falloff_85;
      L_83 = (testPos_82 - P_63);
      lowp float tmpvar_86;
      tmpvar_86 = sqrt(dot (L_83, L_83));
      lowp float tmpvar_87;
      tmpvar_87 = (1.0/(((attenuationFactor.x * 
        (tmpvar_86 * tmpvar_86)
      ) + (attenuationFactor.y * tmpvar_86))));
      lowp vec3 tmpvar_88;
      tmpvar_88 = normalize(L_83);
      L_83 = tmpvar_88;
      falloff_85 = 1.0;
      if ((lightSpot_75.x > 0.0)) {
        lowp float tmpvar_89;
        if ((tmpvar_88.y > lightSpot_75.x)) {
          tmpvar_89 = pow (tmpvar_88.y, lightSpot_75.y);
        } else {
          tmpvar_89 = 0.0;
        };
        falloff_85 = tmpvar_89;
      };
      incidentIntensity_84 = ((lightBrightness_77 * tmpvar_87) * falloff_85);
      lowp float tmpvar_90;
      tmpvar_90 = dot (N_65, tmpvar_88);
      if (((tmpvar_90 > 0.0) && ((
        (incidentIntensity_84.x + incidentIntensity_84.y)
       + incidentIntensity_84.z) > 0.01))) {
        lowp vec3 ray_origin_91;
        ray_origin_91 = P_63;
        lowp vec3 ray_direction_92;
        ray_direction_92 = tmpvar_88;
        lowp float t_hit_93;
        t_hit_93 = tmpvar_86;
        bool tmpvar_94;
        tmpvar_94 = bool(0);
        highp int i_95;
        highp int i_96;
        i_96 = 0;
        while (true) {
          if ((i_96 >= numSpheres)) {
            break;
          };
          lowp float t_hit_97;
          t_hit_97 = t_hit_93;
          bool tmpvar_98;
          lowp vec3 tmpvar_99;
          tmpvar_99 = (sphereCenters[i_96] - ray_origin_91);
          lowp float tmpvar_100;
          tmpvar_100 = dot (tmpvar_99, ray_direction_92);
          if ((tmpvar_100 < 0.0)) {
            tmpvar_98 = bool(0);
          } else {
            lowp float tmpvar_101;
            tmpvar_101 = (dot (tmpvar_99, tmpvar_99) - (tmpvar_100 * tmpvar_100));
            if ((tmpvar_101 > 0.64)) {
              tmpvar_98 = bool(0);
            } else {
              lowp float tmpvar_102;
              tmpvar_102 = sqrt((0.64 - tmpvar_101));
              lowp float tmpvar_103;
              tmpvar_103 = (tmpvar_100 - tmpvar_102);
              lowp float tmpvar_104;
              tmpvar_104 = (tmpvar_100 + tmpvar_102);
              lowp float tmpvar_105;
              if ((tmpvar_103 < 0.001)) {
                tmpvar_105 = tmpvar_104;
              } else {
                tmpvar_105 = tmpvar_103;
              };
              if (((tmpvar_105 < t_hit_93) && (tmpvar_105 > 0.001))) {
                t_hit_97 = tmpvar_105;
                tmpvar_98 = bool(1);
              } else {
                tmpvar_98 = bool(0);
              };
            };
          };
          t_hit_93 = t_hit_97;
          if (tmpvar_98) {
            tmpvar_94 = bool(1);
            break;
          };
          i_96++;
        };
        if (!(tmpvar_94)) {
          i_95 = 0;
          while (true) {
            if ((i_95 >= numPlanes)) {
              break;
            };
            vec3 normal_106;
            normal_106 = planeNormals[i_95];
            lowp float t_hit_107;
            t_hit_107 = t_hit_93;
            bool tmpvar_108;
            tmpvar_108 = bool(1);
            bool tmpvar_109;
            vec3 tmpvar_110;
            tmpvar_110 = (normal_106 * planeOffsets[i_95]);
            lowp float tmpvar_111;
            tmpvar_111 = (((
              (tmpvar_110.x + tmpvar_110.y)
             + tmpvar_110.z) - dot (normal_106, ray_origin_91)) / dot (normal_106, ray_direction_92));
            if (((tmpvar_111 < t_hit_93) && (tmpvar_111 > 0.001))) {
              t_hit_107 = tmpvar_111;
              tmpvar_109 = bool(1);
              tmpvar_108 = bool(0);
            };
            if (tmpvar_108) {
              tmpvar_109 = bool(0);
              tmpvar_108 = bool(0);
            };
            t_hit_93 = t_hit_107;
            if (tmpvar_109) {
              tmpvar_94 = bool(1);
              break;
            };
            i_95++;
          };
          if (!(tmpvar_94)) {
            tmpvar_94 = bool(1);
          };
        };
        lowp float tmpvar_112;
        tmpvar_112 = abs((t_hit_93 - tmpvar_86));
        if ((tmpvar_112 < 0.001)) {
          lowp vec3 I_113;
          I_113 = -(tmpvar_88);
          light_sum_74 = (light_sum_74 + (incidentIntensity_84 * (
            (diffuseColor_66 * dot (N_65, tmpvar_88))
           + 
            (specularColor_67 * pow (max (0.0, dot (
              (I_113 - (2.0 * (dot (N_65, I_113) * N_65)))
            , 
              -(V_64)
            )), 128.0))
          )));
        } else {
          inShade_71 = bool(1);
        };
      } else {
        inShade_71 = bool(1);
      };
      areaShadowSamples_72++;
      k_70++;
    };
    if ((tmpvar_80 && inShade_71)) {
      highp int k_114;
      areaShadowSamples_72 = shadowSamples;
      light_sum_74 = vec3(0.0, 0.0, 0.0);
      k_114 = 0;
      while (true) {
        lowp vec3 incidentIntensity_115;
        if ((k_114 >= areaShadowSamples_72)) {
          break;
        };
        float sample_i_116;
        sample_i_116 = float(k_114);
        lowp vec3 L_117;
        lowp float falloff_118;
        float tmpvar_119;
        tmpvar_119 = (1.0/(shadowDim));
        randomIncrement += 0.02;
        lowp float tmpvar_120;
        tmpvar_120 = ((lightSize_76.x * tmpvar_119) * ((float(mod (sample_i_116, shadowDim))) + fract(
          (cos(dot ((P_63.xy + randomIncrement), vec2(23.14069, 2.665144))) * 12345.68)
        )));
        randomIncrement += 0.02;
        lowp vec3 tmpvar_121;
        tmpvar_121.x = ((lightPos_78.x - (lightSize_76.x * 0.5)) + tmpvar_120);
        tmpvar_121.y = lightPos_78.y;
        tmpvar_121.z = ((lightPos_78.z - (lightSize_76.y * 0.5)) + ((lightSize_76.y * tmpvar_119) * (
          floor((sample_i_116 * tmpvar_119))
         + 
          fract((cos(dot (
            (P_63.yx + randomIncrement)
          , vec2(23.14069, 2.665144))) * 12345.68))
        )));
        L_117 = (tmpvar_121 - P_63);
        lowp float tmpvar_122;
        tmpvar_122 = sqrt(dot (L_117, L_117));
        lowp float tmpvar_123;
        tmpvar_123 = (1.0/(((attenuationFactor.x * 
          (tmpvar_122 * tmpvar_122)
        ) + (attenuationFactor.y * tmpvar_122))));
        lowp vec3 tmpvar_124;
        tmpvar_124 = normalize(L_117);
        L_117 = tmpvar_124;
        falloff_118 = 1.0;
        if ((lightSpot_75.x > 0.0)) {
          lowp float tmpvar_125;
          if ((tmpvar_124.y > lightSpot_75.x)) {
            tmpvar_125 = pow (tmpvar_124.y, lightSpot_75.y);
          } else {
            tmpvar_125 = 0.0;
          };
          falloff_118 = tmpvar_125;
        };
        incidentIntensity_115 = ((lightBrightness_77 * tmpvar_123) * falloff_118);
        lowp vec3 ray_origin_126;
        ray_origin_126 = P_63;
        lowp vec3 ray_direction_127;
        ray_direction_127 = tmpvar_124;
        lowp float t_hit_128;
        t_hit_128 = tmpvar_122;
        bool tmpvar_129;
        bool tmpvar_130;
        tmpvar_130 = bool(0);
        highp int i_131;
        highp int i_132;
        i_132 = 0;
        while (true) {
          if ((i_132 >= numSpheres)) {
            break;
          };
          lowp float t_hit_133;
          t_hit_133 = t_hit_128;
          bool tmpvar_134;
          lowp vec3 tmpvar_135;
          tmpvar_135 = (sphereCenters[i_132] - ray_origin_126);
          lowp float tmpvar_136;
          tmpvar_136 = dot (tmpvar_135, ray_direction_127);
          if ((tmpvar_136 < 0.0)) {
            tmpvar_134 = bool(0);
          } else {
            lowp float tmpvar_137;
            tmpvar_137 = (dot (tmpvar_135, tmpvar_135) - (tmpvar_136 * tmpvar_136));
            if ((tmpvar_137 > 0.64)) {
              tmpvar_134 = bool(0);
            } else {
              lowp float tmpvar_138;
              tmpvar_138 = sqrt((0.64 - tmpvar_137));
              lowp float tmpvar_139;
              tmpvar_139 = (tmpvar_136 - tmpvar_138);
              lowp float tmpvar_140;
              tmpvar_140 = (tmpvar_136 + tmpvar_138);
              lowp float tmpvar_141;
              if ((tmpvar_139 < 0.001)) {
                tmpvar_141 = tmpvar_140;
              } else {
                tmpvar_141 = tmpvar_139;
              };
              if (((tmpvar_141 < t_hit_128) && (tmpvar_141 > 0.001))) {
                t_hit_133 = tmpvar_141;
                tmpvar_134 = bool(1);
              } else {
                tmpvar_134 = bool(0);
              };
            };
          };
          t_hit_128 = t_hit_133;
          if (tmpvar_134) {
            tmpvar_129 = bool(1);
            tmpvar_130 = bool(1);
            break;
          };
          i_132++;
        };
        if (!(tmpvar_130)) {
          i_131 = 0;
          while (true) {
            if ((i_131 >= numPlanes)) {
              break;
            };
            vec3 normal_142;
            normal_142 = planeNormals[i_131];
            lowp float t_hit_143;
            t_hit_143 = t_hit_128;
            bool tmpvar_144;
            tmpvar_144 = bool(1);
            bool tmpvar_145;
            vec3 tmpvar_146;
            tmpvar_146 = (normal_142 * planeOffsets[i_131]);
            lowp float tmpvar_147;
            tmpvar_147 = (((
              (tmpvar_146.x + tmpvar_146.y)
             + tmpvar_146.z) - dot (normal_142, ray_origin_126)) / dot (normal_142, ray_direction_127));
            if (((tmpvar_147 < t_hit_128) && (tmpvar_147 > 0.001))) {
              t_hit_143 = tmpvar_147;
              tmpvar_145 = bool(1);
              tmpvar_144 = bool(0);
            };
            if (tmpvar_144) {
              tmpvar_145 = bool(0);
              tmpvar_144 = bool(0);
            };
            t_hit_128 = t_hit_143;
            if (tmpvar_145) {
              tmpvar_129 = bool(1);
              tmpvar_130 = bool(1);
              break;
            };
            i_131++;
          };
          if (!(tmpvar_130)) {
            tmpvar_129 = bool(0);
            tmpvar_130 = bool(1);
          };
        };
        if (!(tmpvar_129)) {
          lowp vec3 I_148;
          I_148 = -(tmpvar_124);
          light_sum_74 = (light_sum_74 + (incidentIntensity_115 * (
            (diffuseColor_66 * dot (N_65, tmpvar_124))
           + 
            (specularColor_67 * pow (max (0.0, dot (
              (I_148 - (2.0 * (dot (N_65, I_148) * N_65)))
            , 
              -(V_64)
            )), 128.0))
          )));
        };
        k_114++;
      };
    };
    illuminationColor_69 = (illuminationColor_69 + (light_sum_74 / float(areaShadowSamples_72)));
  };
  pixelColor_5 = (pixelColor_5 + (roughness_15 * illuminationColor_69));
  if ((((enableGI && 
    (diffuseColor_12.x > 0.0)
  ) && (diffuseColor_12.y > 0.0)) && (diffuseColor_12.z > 0.0))) {
    if ((roughness_15 < 1.0)) {
      lowp vec3 P_149;
      P_149 = position_10;
      lowp vec3 V_150;
      V_150 = tmpvar_6;
      lowp vec3 N_151;
      N_151 = normal_11;
      float G1_alpha2_153;
      float VNDF_alpha_154;
      lowp mat3 basis_155;
      lowp vec3 indirect_sampling_sum_156;
      lowp mat3 ret_157;
      ret_157[1] = normal_11;
      if ((normal_11.z < -0.9998057)) {
        ret_157[0] = vec3(0.0, -1.0, 0.0);
        ret_157[2] = vec3(-1.0, 0.0, 0.0);
      } else {
        lowp float tmpvar_158;
        tmpvar_158 = (1.0/((1.0 + normal_11.z)));
        lowp float tmpvar_159;
        tmpvar_159 = ((-(normal_11.x) * normal_11.y) * tmpvar_158);
        lowp vec3 tmpvar_160;
        tmpvar_160.x = (1.0 - ((normal_11.x * normal_11.x) * tmpvar_158));
        tmpvar_160.y = tmpvar_159;
        tmpvar_160.z = -(normal_11.x);
        ret_157[0] = tmpvar_160;
        lowp vec3 tmpvar_161;
        tmpvar_161.x = tmpvar_159;
        tmpvar_161.y = (1.0 - ((normal_11.y * normal_11.y) * tmpvar_158));
        tmpvar_161.z = -(normal_11.y);
        ret_157[2] = tmpvar_161;
      };
      basis_155 = ret_157;
      VNDF_alpha_154 = (roughness_15 * roughness_15);
      float tmpvar_162;
      tmpvar_162 = max (roughness_15, 0.02);
      float tmpvar_163;
      tmpvar_163 = (tmpvar_162 * tmpvar_162);
      G1_alpha2_153 = ((tmpvar_163 * tmpvar_163) + (1.0 - (tmpvar_163 * tmpvar_163)));
      for (highp int i_152 = 0; i_152 < indirectSamples; i_152++) {
        float roughness2_164;
        vec3 reflective2_165;
        vec3 specular2_166;
        lowp vec3 diffuse2_167;
        lowp float G1_NoR_168;
        randomIncrement += 0.02;
        lowp float tmpvar_169;
        tmpvar_169 = fract((cos(
          dot ((P_149.xz + randomIncrement), vec2(23.14069, 2.665144))
        ) * 12345.68));
        randomIncrement += 0.02;
        lowp float tmpvar_170;
        tmpvar_170 = fract((cos(
          dot ((P_149.xy + randomIncrement), vec2(23.14069, 2.665144))
        ) * 12345.68));
        lowp float t2_171;
        lowp vec3 tmpvar_172;
        tmpvar_172.x = dot (V_150, basis_155[0]);
        tmpvar_172.y = dot (V_150, basis_155[2]);
        tmpvar_172.z = dot (V_150, basis_155[1]);
        lowp vec3 tmpvar_173;
        tmpvar_173 = -(tmpvar_172);
        lowp vec3 tmpvar_174;
        tmpvar_174.xy = (vec2(VNDF_alpha_154) * tmpvar_173.xy);
        tmpvar_174.z = tmpvar_173.z;
        lowp vec3 tmpvar_175;
        tmpvar_175 = normalize(tmpvar_174);
        lowp float tmpvar_176;
        tmpvar_176 = ((tmpvar_175.x * tmpvar_175.x) + (tmpvar_175.y * tmpvar_175.y));
        lowp vec3 tmpvar_177;
        if ((tmpvar_176 > 0.0)) {
          lowp vec3 tmpvar_178;
          tmpvar_178.z = 0.0;
          tmpvar_178.x = -(tmpvar_175.y);
          tmpvar_178.y = tmpvar_175.x;
          tmpvar_177 = (tmpvar_178 * inversesqrt(tmpvar_176));
        } else {
          tmpvar_177 = vec3(1.0, 0.0, 0.0);
        };
        lowp float tmpvar_179;
        tmpvar_179 = sqrt(tmpvar_169);
        lowp float tmpvar_180;
        tmpvar_180 = (6.283186 * tmpvar_170);
        lowp float tmpvar_181;
        tmpvar_181 = (tmpvar_179 * cos(tmpvar_180));
        lowp float tmpvar_182;
        tmpvar_182 = (0.5 * (1.0 + tmpvar_175.z));
        t2_171 = (((1.0 - tmpvar_182) * sqrt(
          (1.0 - (tmpvar_181 * tmpvar_181))
        )) + (tmpvar_182 * (tmpvar_179 * 
          sin(tmpvar_180)
        )));
        lowp vec3 tmpvar_183;
        tmpvar_183 = (((tmpvar_181 * tmpvar_177) + (t2_171 * 
          ((tmpvar_175.yzx * tmpvar_177.zxy) - (tmpvar_175.zxy * tmpvar_177.yzx))
        )) + (sqrt(
          max (0.0, ((1.0 - (tmpvar_181 * tmpvar_181)) - (t2_171 * t2_171)))
        ) * tmpvar_175));
        lowp vec3 tmpvar_184;
        tmpvar_184.x = (VNDF_alpha_154 * tmpvar_183.x);
        tmpvar_184.y = max (0.0, tmpvar_183.z);
        tmpvar_184.z = (VNDF_alpha_154 * tmpvar_183.y);
        lowp vec3 tmpvar_185;
        tmpvar_185 = normalize((basis_155 * tmpvar_184));
        lowp vec3 tmpvar_186;
        tmpvar_186 = (V_150 - (2.0 * (
          dot (tmpvar_185, V_150)
         * tmpvar_185)));
        lowp float tmpvar_187;
        tmpvar_187 = max (0.0, dot (N_151, tmpvar_186));
        G1_NoR_168 = ((2.0 * tmpvar_187) / (tmpvar_187 + sqrt(
          (G1_alpha2_153 * (tmpvar_187 * tmpvar_187))
        )));
        lowp vec3 tmpvar_188;
        tmpvar_188 = normalize(tmpvar_186);
        lowp vec3 ray_origin_189;
        ray_origin_189 = P_149;
        lowp vec3 ray_direction_190;
        ray_direction_190 = tmpvar_188;
        lowp float t_hit_191;
        t_hit_191 = 20.0;
        lowp vec3 position_192;
        lowp vec3 normal_193;
        lowp vec3 diffuseColor_194;
        diffuseColor_194 = diffuse2_167;
        vec3 specularColor_195;
        specularColor_195 = specular2_166;
        vec3 reflectiveColor_196;
        reflectiveColor_196 = reflective2_165;
        float roughness_197;
        roughness_197 = roughness2_164;
        bool intersectLight_198;
        intersectLight_198 = bool(1);
        highp int idx_201;
        highp int intersected_202;
        intersected_202 = 0;
        idx_201 = 0;
        for (highp int i_200 = 0; i_200 < numSpheres; i_200++) {
          lowp float t_hit_203;
          t_hit_203 = t_hit_191;
          bool tmpvar_204;
          lowp vec3 tmpvar_205;
          tmpvar_205 = (sphereCenters[i_200] - ray_origin_189);
          lowp float tmpvar_206;
          tmpvar_206 = dot (tmpvar_205, ray_direction_190);
          if ((tmpvar_206 < 0.0)) {
            tmpvar_204 = bool(0);
          } else {
            lowp float tmpvar_207;
            tmpvar_207 = (dot (tmpvar_205, tmpvar_205) - (tmpvar_206 * tmpvar_206));
            if ((tmpvar_207 > 0.64)) {
              tmpvar_204 = bool(0);
            } else {
              lowp float tmpvar_208;
              tmpvar_208 = sqrt((0.64 - tmpvar_207));
              lowp float tmpvar_209;
              tmpvar_209 = (tmpvar_206 - tmpvar_208);
              lowp float tmpvar_210;
              tmpvar_210 = (tmpvar_206 + tmpvar_208);
              lowp float tmpvar_211;
              if ((tmpvar_209 < 0.01)) {
                tmpvar_211 = tmpvar_210;
              } else {
                tmpvar_211 = tmpvar_209;
              };
              if (((tmpvar_211 < t_hit_191) && (tmpvar_211 > 0.01))) {
                t_hit_203 = tmpvar_211;
                tmpvar_204 = bool(1);
              } else {
                tmpvar_204 = bool(0);
              };
            };
          };
          t_hit_191 = t_hit_203;
          if (tmpvar_204) {
            idx_201 = i_200;
            intersected_202 = 1;
          };
        };
        for (highp int i_199 = 0; i_199 < numPlanes; i_199++) {
          lowp vec3 tmpvar_212;
          tmpvar_212 = planeNormals[i_199];
          bool tmpvar_213;
          if (enablePlaneBacksides) {
            tmpvar_213 = bool(1);
          } else {
            tmpvar_213 = (dot (ray_direction_190, tmpvar_212) < 0.0);
          };
          if (tmpvar_213) {
            lowp float t_hit_214;
            t_hit_214 = t_hit_191;
            bool tmpvar_215;
            tmpvar_215 = bool(1);
            bool tmpvar_216;
            lowp vec3 tmpvar_217;
            tmpvar_217 = (tmpvar_212 * planeOffsets[i_199]);
            lowp float tmpvar_218;
            tmpvar_218 = (((
              (tmpvar_217.x + tmpvar_217.y)
             + tmpvar_217.z) - dot (tmpvar_212, ray_origin_189)) / dot (tmpvar_212, ray_direction_190));
            if (((tmpvar_218 < t_hit_191) && (tmpvar_218 > 0.01))) {
              t_hit_214 = tmpvar_218;
              tmpvar_216 = bool(1);
              tmpvar_215 = bool(0);
            };
            if (tmpvar_215) {
              tmpvar_216 = bool(0);
              tmpvar_215 = bool(0);
            };
            t_hit_191 = t_hit_214;
            if (tmpvar_216) {
              normal_193 = tmpvar_212;
              idx_201 = i_199;
              intersected_202 = 2;
            };
          };
        };
        intersectLight_198 = bool(0);
        for (highp int i_219 = 0; i_219 < numLights; i_219++) {
          bool tmp_220;
          vec3 tmpvar_221;
          tmpvar_221 = lightPos[i_219];
          vec2 tmpvar_222;
          tmpvar_222 = lightSize[i_219];
          tmp_220 = bool(0);
          if (((tmpvar_222.x > 0.0) && (tmpvar_222.y > 0.0))) {
            lowp float t_hit_223;
            t_hit_223 = t_hit_191;
            bool tmpvar_224;
            tmpvar_224 = bool(1);
            bool tmpvar_225;
            vec3 tmpvar_226;
            tmpvar_226 = (vec3(0.0, 1.0, 0.0) * tmpvar_221.y);
            lowp float tmpvar_227;
            tmpvar_227 = (((
              (tmpvar_226.x + tmpvar_226.y)
             + tmpvar_226.z) - ray_origin_189.y) / ray_direction_190.y);
            if (((tmpvar_227 < t_hit_191) && (tmpvar_227 > 0.01))) {
              lowp vec3 tmpvar_228;
              tmpvar_228 = (ray_origin_189 + (ray_direction_190 * tmpvar_227));
              if ((((tmpvar_222.x + tmpvar_222.y) == 0.0) || ((
                ((tmpvar_228.x < (tmpvar_221.x + (tmpvar_222.x * 0.5))) && (tmpvar_228.x > (tmpvar_221.x - (tmpvar_222.x * 0.5))))
               && 
                (tmpvar_228.z < (tmpvar_221.z + (tmpvar_222.y * 0.5)))
              ) && (tmpvar_228.z > 
                (tmpvar_221.z - (tmpvar_222.y * 0.5))
              )))) {
                t_hit_223 = tmpvar_227;
                tmpvar_225 = bool(1);
                tmpvar_224 = bool(0);
              };
            };
            if (tmpvar_224) {
              tmpvar_225 = bool(0);
              tmpvar_224 = bool(0);
            };
            t_hit_191 = t_hit_223;
            tmp_220 = tmpvar_225;
          } else {
            lowp float t_hit_229;
            t_hit_229 = t_hit_191;
            bool tmpvar_230;
            lowp vec3 tmpvar_231;
            tmpvar_231 = (tmpvar_221 - ray_origin_189);
            lowp float tmpvar_232;
            tmpvar_232 = dot (tmpvar_231, ray_direction_190);
            if ((tmpvar_232 < 0.0)) {
              tmpvar_230 = bool(0);
            } else {
              lowp float tmpvar_233;
              tmpvar_233 = (dot (tmpvar_231, tmpvar_231) - (tmpvar_232 * tmpvar_232));
              if ((tmpvar_233 > 0.01)) {
                tmpvar_230 = bool(0);
              } else {
                lowp float tmpvar_234;
                tmpvar_234 = sqrt((0.01 - tmpvar_233));
                lowp float tmpvar_235;
                tmpvar_235 = (tmpvar_232 - tmpvar_234);
                lowp float tmpvar_236;
                tmpvar_236 = (tmpvar_232 + tmpvar_234);
                lowp float tmpvar_237;
                if ((tmpvar_235 < 0.01)) {
                  tmpvar_237 = tmpvar_236;
                } else {
                  tmpvar_237 = tmpvar_235;
                };
                if (((tmpvar_237 < t_hit_191) && (tmpvar_237 > 0.01))) {
                  t_hit_229 = tmpvar_237;
                  tmpvar_230 = bool(1);
                } else {
                  tmpvar_230 = bool(0);
                };
              };
            };
            t_hit_191 = t_hit_229;
            tmp_220 = tmpvar_230;
          };
          if (tmp_220) {
            idx_201 = i_219;
            intersected_202 = 3;
          };
        };
        position_192 = (P_149 + (tmpvar_188 * t_hit_191));
        if ((intersected_202 == 1)) {
          diffuseColor_194 = sphereColors[idx_201];
          specularColor_195 = sphereSpecColors[idx_201];
          reflectiveColor_196 = reflectiveColors[idx_201];
          roughness_197 = sphereRoughness[idx_201];
          lowp vec3 tmpvar_238;
          tmpvar_238 = normalize((position_192 - sphereCenters[idx_201]));
          normal_193 = tmpvar_238;
          lowp float tmpvar_239;
          tmpvar_239 = dot (tmpvar_238, -(tmpvar_188));
          if ((tmpvar_239 < 0.0)) {
            normal_193 = -(tmpvar_238);
          };
        } else {
          if ((intersected_202 == 2)) {
            if (!(enablePlaneMirrors)) {
              diffuseColor_194 = planeColors[idx_201];
              specularColor_195 = vec3(planeSpecular[idx_201]);
              reflectiveColor_196 = vec3(0.0, 0.0, 0.0);
              roughness_197 = planeRoughness[idx_201];
            } else {
              diffuseColor_194 = (planeColors[idx_201] * 0.01);
              specularColor_195 = vec3(0.0, 0.0, 0.0);
              reflectiveColor_196 = planeColors[idx_201];
              roughness_197 = 1.0;
            };
            lowp float tmpvar_240;
            tmpvar_240 = dot (normal_193, -(tmpvar_188));
            if ((tmpvar_240 < 0.0)) {
              normal_193 = -(normal_193);
            };
          } else {
            if ((intersected_202 == 3)) {
              lowp float spot_falloff_241;
              spot_falloff_241 = 1.0;
              vec2 tmpvar_242;
              tmpvar_242 = lightSpot[idx_201];
              if ((tmpvar_242.x > 0.0)) {
                lowp float tmpvar_243;
                if ((tmpvar_188.y > tmpvar_242.x)) {
                  tmpvar_243 = pow (tmpvar_188.y, tmpvar_242.y);
                } else {
                  tmpvar_243 = 0.0;
                };
                spot_falloff_241 = tmpvar_243;
              };
              diffuseColor_194 = ((spot_falloff_241 * lightBrightness[idx_201]) * 0.2);
              intersectLight_198 = bool(1);
            };
          };
        };
        diffuse2_167 = diffuseColor_194;
        specular2_166 = specularColor_195;
        reflective2_165 = reflectiveColor_196;
        roughness2_164 = roughness_197;
        lowp vec3 tmpvar_244;
        if (intersectLight_198) {
          tmpvar_244 = diffuseColor_194;
        } else {
          lowp vec3 P_245;
          P_245 = position_192;
          lowp vec3 N_246;
          N_246 = normal_193;
          lowp vec3 diffuseColor_247;
          diffuseColor_247 = (diffuseColor_194 + reflectiveColor_196);
          highp int i_248;
          lowp vec3 illuminationColor_249;
          i_248 = 0;
          while (true) {
            lowp float spotAttenuation_250;
            if ((i_248 >= numLights)) {
              break;
            };
            lowp vec3 tmpvar_251;
            tmpvar_251 = (lightPos[i_248] - P_245);
            lowp float tmpvar_252;
            tmpvar_252 = sqrt(dot (tmpvar_251, tmpvar_251));
            lowp vec3 tmpvar_253;
            tmpvar_253 = normalize(tmpvar_251);
            vec2 tmpvar_254;
            tmpvar_254 = lightSpot[i_248];
            spotAttenuation_250 = 1.0;
            if ((tmpvar_254.x > 0.0)) {
              lowp float tmpvar_255;
              if ((tmpvar_253.y > tmpvar_254.x)) {
                tmpvar_255 = pow (tmpvar_253.y, tmpvar_254.y);
              } else {
                tmpvar_255 = 0.0;
              };
              spotAttenuation_250 = tmpvar_255;
            };
            if ((spotAttenuation_250 > 0.0)) {
              vec3 lightBrightness_256;
              lightBrightness_256 = lightBrightness[i_248];
              lowp float tmpvar_257;
              tmpvar_257 = (1.0/(((attenuationFactor.x * 
                (tmpvar_252 * tmpvar_252)
              ) + (attenuationFactor.y * tmpvar_252))));
              if ((tmpvar_257 > 0.004)) {
                lowp float tmpvar_258;
                tmpvar_258 = dot (N_246, tmpvar_253);
                if ((tmpvar_258 > 0.0)) {
                  lowp vec3 ray_origin_259;
                  ray_origin_259 = P_245;
                  lowp vec3 ray_direction_260;
                  ray_direction_260 = tmpvar_253;
                  lowp float t_hit_261;
                  t_hit_261 = tmpvar_252;
                  bool tmpvar_262;
                  bool tmpvar_263;
                  tmpvar_263 = bool(0);
                  highp int i_264;
                  highp int i_265;
                  i_265 = 0;
                  while (true) {
                    if ((i_265 >= numSpheres)) {
                      break;
                    };
                    lowp float t_hit_266;
                    t_hit_266 = t_hit_261;
                    bool tmpvar_267;
                    lowp vec3 tmpvar_268;
                    tmpvar_268 = (sphereCenters[i_265] - ray_origin_259);
                    lowp float tmpvar_269;
                    tmpvar_269 = dot (tmpvar_268, ray_direction_260);
                    if ((tmpvar_269 < 0.0)) {
                      tmpvar_267 = bool(0);
                    } else {
                      lowp float tmpvar_270;
                      tmpvar_270 = (dot (tmpvar_268, tmpvar_268) - (tmpvar_269 * tmpvar_269));
                      if ((tmpvar_270 > 0.64)) {
                        tmpvar_267 = bool(0);
                      } else {
                        lowp float tmpvar_271;
                        tmpvar_271 = sqrt((0.64 - tmpvar_270));
                        lowp float tmpvar_272;
                        tmpvar_272 = (tmpvar_269 - tmpvar_271);
                        lowp float tmpvar_273;
                        tmpvar_273 = (tmpvar_269 + tmpvar_271);
                        lowp float tmpvar_274;
                        if ((tmpvar_272 < 0.001)) {
                          tmpvar_274 = tmpvar_273;
                        } else {
                          tmpvar_274 = tmpvar_272;
                        };
                        if (((tmpvar_274 < t_hit_261) && (tmpvar_274 > 0.001))) {
                          t_hit_266 = tmpvar_274;
                          tmpvar_267 = bool(1);
                        } else {
                          tmpvar_267 = bool(0);
                        };
                      };
                    };
                    t_hit_261 = t_hit_266;
                    if (tmpvar_267) {
                      tmpvar_262 = bool(1);
                      tmpvar_263 = bool(1);
                      break;
                    };
                    i_265++;
                  };
                  if (!(tmpvar_263)) {
                    i_264 = 0;
                    while (true) {
                      if ((i_264 >= numPlanes)) {
                        break;
                      };
                      vec3 normal_275;
                      normal_275 = planeNormals[i_264];
                      lowp float t_hit_276;
                      t_hit_276 = t_hit_261;
                      bool tmpvar_277;
                      tmpvar_277 = bool(1);
                      bool tmpvar_278;
                      vec3 tmpvar_279;
                      tmpvar_279 = (normal_275 * planeOffsets[i_264]);
                      lowp float tmpvar_280;
                      tmpvar_280 = (((
                        (tmpvar_279.x + tmpvar_279.y)
                       + tmpvar_279.z) - dot (normal_275, ray_origin_259)) / dot (normal_275, ray_direction_260));
                      if (((tmpvar_280 < t_hit_261) && (tmpvar_280 > 0.001))) {
                        t_hit_276 = tmpvar_280;
                        tmpvar_278 = bool(1);
                        tmpvar_277 = bool(0);
                      };
                      if (tmpvar_277) {
                        tmpvar_278 = bool(0);
                        tmpvar_277 = bool(0);
                      };
                      t_hit_261 = t_hit_276;
                      if (tmpvar_278) {
                        tmpvar_262 = bool(1);
                        tmpvar_263 = bool(1);
                        break;
                      };
                      i_264++;
                    };
                    if (!(tmpvar_263)) {
                      tmpvar_262 = bool(0);
                      tmpvar_263 = bool(1);
                    };
                  };
                  if (!(tmpvar_262)) {
                    illuminationColor_249 = (illuminationColor_249 + ((diffuseColor_247 * lightBrightness_256) * (
                      (tmpvar_257 * spotAttenuation_250)
                     * tmpvar_258)));
                  };
                };
              };
            };
            i_248++;
          };
          tmpvar_244 = (G1_NoR_168 * illuminationColor_249);
        };
        indirect_sampling_sum_156 = (indirect_sampling_sum_156 + tmpvar_244);
      };
      pixelColor_5 = (pixelColor_5 + ((indirect_sampling_sum_156 / 
        float(indirectSamples)
      ) * diffuseColor_12));
    } else {
      lowp vec3 P_281;
      P_281 = position_10;
      lowp vec3 N_282;
      N_282 = normal_11;
      lowp vec3 indirect_sampling_sum_284;
      for (highp int i_283 = 0; i_283 < indirectSamples; i_283++) {
        float roughness2_285;
        vec3 reflective2_286;
        vec3 specular2_287;
        lowp vec3 diffuse2_288;
        float sampleIdx_289;
        sampleIdx_289 = float(i_283);
        randomIncrement += 0.02;
        lowp float tmpvar_290;
        tmpvar_290 = ((1.0 - (
          (sampleIdx_289 / float((indirectSamples - 1)))
         * 2.0)) + ((
          fract((cos(dot (
            (P_281.xy + randomIncrement)
          , vec2(23.14069, 2.665144))) * 12345.68))
         * 0.4) - 0.2));
        lowp float tmpvar_291;
        tmpvar_291 = sqrt((1.0 - (tmpvar_290 * tmpvar_290)));
        randomIncrement += 0.02;
        lowp float tmpvar_292;
        tmpvar_292 = ((2.399963 * sampleIdx_289) + ((
          fract((cos(dot (
            (P_281.xy + randomIncrement)
          , vec2(23.14069, 2.665144))) * 12345.68))
         * 0.5) - 0.25));
        lowp vec3 tmpvar_293;
        tmpvar_293.x = (cos(tmpvar_292) * tmpvar_291);
        tmpvar_293.y = tmpvar_290;
        tmpvar_293.z = (sin(tmpvar_292) * tmpvar_291);
        lowp vec3 ray_origin_294;
        ray_origin_294 = P_281;
        lowp vec3 ray_direction_295;
        ray_direction_295 = normalize(normalize((N_282 + tmpvar_293)));
        lowp float t_hit_296;
        t_hit_296 = 10.0;
        lowp vec3 position_297;
        lowp vec3 normal_298;
        lowp vec3 diffuseColor_299;
        diffuseColor_299 = diffuse2_288;
        vec3 specularColor_300;
        specularColor_300 = specular2_287;
        vec3 reflectiveColor_301;
        reflectiveColor_301 = reflective2_286;
        float roughness_302;
        roughness_302 = roughness2_285;
        highp int idx_305;
        highp int intersected_306;
        intersected_306 = 0;
        idx_305 = 0;
        for (highp int i_304 = 0; i_304 < numSpheres; i_304++) {
          lowp float t_hit_307;
          t_hit_307 = t_hit_296;
          bool tmpvar_308;
          lowp vec3 tmpvar_309;
          tmpvar_309 = (sphereCenters[i_304] - ray_origin_294);
          lowp float tmpvar_310;
          tmpvar_310 = dot (tmpvar_309, ray_direction_295);
          if ((tmpvar_310 < 0.0)) {
            tmpvar_308 = bool(0);
          } else {
            lowp float tmpvar_311;
            tmpvar_311 = (dot (tmpvar_309, tmpvar_309) - (tmpvar_310 * tmpvar_310));
            if ((tmpvar_311 > 0.64)) {
              tmpvar_308 = bool(0);
            } else {
              lowp float tmpvar_312;
              tmpvar_312 = sqrt((0.64 - tmpvar_311));
              lowp float tmpvar_313;
              tmpvar_313 = (tmpvar_310 - tmpvar_312);
              lowp float tmpvar_314;
              tmpvar_314 = (tmpvar_310 + tmpvar_312);
              lowp float tmpvar_315;
              if ((tmpvar_313 < 0.01)) {
                tmpvar_315 = tmpvar_314;
              } else {
                tmpvar_315 = tmpvar_313;
              };
              if (((tmpvar_315 < t_hit_296) && (tmpvar_315 > 0.01))) {
                t_hit_307 = tmpvar_315;
                tmpvar_308 = bool(1);
              } else {
                tmpvar_308 = bool(0);
              };
            };
          };
          t_hit_296 = t_hit_307;
          if (tmpvar_308) {
            idx_305 = i_304;
            intersected_306 = 1;
          };
        };
        for (highp int i_303 = 0; i_303 < numPlanes; i_303++) {
          lowp vec3 tmpvar_316;
          tmpvar_316 = planeNormals[i_303];
          bool tmpvar_317;
          if (enablePlaneBacksides) {
            tmpvar_317 = bool(1);
          } else {
            tmpvar_317 = (dot (ray_direction_295, tmpvar_316) < 0.0);
          };
          if (tmpvar_317) {
            lowp float t_hit_318;
            t_hit_318 = t_hit_296;
            bool tmpvar_319;
            tmpvar_319 = bool(1);
            bool tmpvar_320;
            lowp vec3 tmpvar_321;
            tmpvar_321 = (tmpvar_316 * planeOffsets[i_303]);
            lowp float tmpvar_322;
            tmpvar_322 = (((
              (tmpvar_321.x + tmpvar_321.y)
             + tmpvar_321.z) - dot (tmpvar_316, ray_origin_294)) / dot (tmpvar_316, ray_direction_295));
            if (((tmpvar_322 < t_hit_296) && (tmpvar_322 > 0.01))) {
              t_hit_318 = tmpvar_322;
              tmpvar_320 = bool(1);
              tmpvar_319 = bool(0);
            };
            if (tmpvar_319) {
              tmpvar_320 = bool(0);
              tmpvar_319 = bool(0);
            };
            t_hit_296 = t_hit_318;
            if (tmpvar_320) {
              normal_298 = tmpvar_316;
              idx_305 = i_303;
              intersected_306 = 2;
            };
          };
        };
        position_297 = (P_281 + (ray_direction_295 * t_hit_296));
        if ((intersected_306 == 1)) {
          diffuseColor_299 = sphereColors[idx_305];
          specularColor_300 = sphereSpecColors[idx_305];
          reflectiveColor_301 = reflectiveColors[idx_305];
          roughness_302 = sphereRoughness[idx_305];
          lowp vec3 tmpvar_323;
          tmpvar_323 = normalize((position_297 - sphereCenters[idx_305]));
          normal_298 = tmpvar_323;
          lowp float tmpvar_324;
          tmpvar_324 = dot (tmpvar_323, -(ray_direction_295));
          if ((tmpvar_324 < 0.0)) {
            normal_298 = -(tmpvar_323);
          };
        } else {
          if ((intersected_306 == 2)) {
            if (!(enablePlaneMirrors)) {
              diffuseColor_299 = planeColors[idx_305];
              specularColor_300 = vec3(planeSpecular[idx_305]);
              reflectiveColor_301 = vec3(0.0, 0.0, 0.0);
              roughness_302 = planeRoughness[idx_305];
            } else {
              diffuseColor_299 = (planeColors[idx_305] * 0.01);
              specularColor_300 = vec3(0.0, 0.0, 0.0);
              reflectiveColor_301 = planeColors[idx_305];
              roughness_302 = 1.0;
            };
            lowp float tmpvar_325;
            tmpvar_325 = dot (normal_298, -(ray_direction_295));
            if ((tmpvar_325 < 0.0)) {
              normal_298 = -(normal_298);
            };
          } else {
            if ((intersected_306 == 3)) {
              lowp float spot_falloff_326;
              spot_falloff_326 = 1.0;
              vec2 tmpvar_327;
              tmpvar_327 = lightSpot[idx_305];
              if ((tmpvar_327.x > 0.0)) {
                lowp float tmpvar_328;
                if ((ray_direction_295.y > tmpvar_327.x)) {
                  tmpvar_328 = pow (ray_direction_295.y, tmpvar_327.y);
                } else {
                  tmpvar_328 = 0.0;
                };
                spot_falloff_326 = tmpvar_328;
              };
              diffuseColor_299 = ((spot_falloff_326 * lightBrightness[idx_305]) * 0.2);
            };
          };
        };
        diffuse2_288 = diffuseColor_299;
        specular2_287 = specularColor_300;
        reflective2_286 = reflectiveColor_301;
        roughness2_285 = roughness_302;
        lowp vec3 P_329;
        P_329 = position_297;
        lowp vec3 N_330;
        N_330 = normal_298;
        lowp vec3 diffuseColor_331;
        diffuseColor_331 = (diffuseColor_299 + reflectiveColor_301);
        lowp vec3 illuminationColor_333;
        for (highp int i_332 = 0; i_332 < numLights; i_332++) {
          lowp float spotAttenuation_334;
          lowp vec3 tmpvar_335;
          tmpvar_335 = (lightPos[i_332] - P_329);
          lowp float tmpvar_336;
          tmpvar_336 = sqrt(dot (tmpvar_335, tmpvar_335));
          lowp vec3 tmpvar_337;
          tmpvar_337 = normalize(tmpvar_335);
          vec2 tmpvar_338;
          tmpvar_338 = lightSpot[i_332];
          spotAttenuation_334 = 1.0;
          if ((tmpvar_338.x > 0.0)) {
            lowp float tmpvar_339;
            if ((tmpvar_337.y > tmpvar_338.x)) {
              tmpvar_339 = pow (tmpvar_337.y, tmpvar_338.y);
            } else {
              tmpvar_339 = 0.0;
            };
            spotAttenuation_334 = tmpvar_339;
          };
          if ((spotAttenuation_334 > 0.0)) {
            vec3 lightBrightness_340;
            lightBrightness_340 = lightBrightness[i_332];
            lowp float tmpvar_341;
            tmpvar_341 = (1.0/(((attenuationFactor.x * 
              (tmpvar_336 * tmpvar_336)
            ) + (attenuationFactor.y * tmpvar_336))));
            if ((tmpvar_341 > 0.004)) {
              lowp float tmpvar_342;
              tmpvar_342 = dot (N_330, tmpvar_337);
              if ((tmpvar_342 > 0.0)) {
                lowp vec3 ray_origin_343;
                ray_origin_343 = P_329;
                lowp vec3 ray_direction_344;
                ray_direction_344 = tmpvar_337;
                lowp float t_hit_345;
                t_hit_345 = tmpvar_336;
                bool tmpvar_346;
                bool tmpvar_347;
                tmpvar_347 = bool(0);
                highp int i_348;
                highp int i_349;
                i_349 = 0;
                while (true) {
                  if ((i_349 >= numSpheres)) {
                    break;
                  };
                  lowp float t_hit_350;
                  t_hit_350 = t_hit_345;
                  bool tmpvar_351;
                  lowp vec3 tmpvar_352;
                  tmpvar_352 = (sphereCenters[i_349] - ray_origin_343);
                  lowp float tmpvar_353;
                  tmpvar_353 = dot (tmpvar_352, ray_direction_344);
                  if ((tmpvar_353 < 0.0)) {
                    tmpvar_351 = bool(0);
                  } else {
                    lowp float tmpvar_354;
                    tmpvar_354 = (dot (tmpvar_352, tmpvar_352) - (tmpvar_353 * tmpvar_353));
                    if ((tmpvar_354 > 0.64)) {
                      tmpvar_351 = bool(0);
                    } else {
                      lowp float tmpvar_355;
                      tmpvar_355 = sqrt((0.64 - tmpvar_354));
                      lowp float tmpvar_356;
                      tmpvar_356 = (tmpvar_353 - tmpvar_355);
                      lowp float tmpvar_357;
                      tmpvar_357 = (tmpvar_353 + tmpvar_355);
                      lowp float tmpvar_358;
                      if ((tmpvar_356 < 0.001)) {
                        tmpvar_358 = tmpvar_357;
                      } else {
                        tmpvar_358 = tmpvar_356;
                      };
                      if (((tmpvar_358 < t_hit_345) && (tmpvar_358 > 0.001))) {
                        t_hit_350 = tmpvar_358;
                        tmpvar_351 = bool(1);
                      } else {
                        tmpvar_351 = bool(0);
                      };
                    };
                  };
                  t_hit_345 = t_hit_350;
                  if (tmpvar_351) {
                    tmpvar_346 = bool(1);
                    tmpvar_347 = bool(1);
                    break;
                  };
                  i_349++;
                };
                if (!(tmpvar_347)) {
                  i_348 = 0;
                  while (true) {
                    if ((i_348 >= numPlanes)) {
                      break;
                    };
                    vec3 normal_359;
                    normal_359 = planeNormals[i_348];
                    lowp float t_hit_360;
                    t_hit_360 = t_hit_345;
                    bool tmpvar_361;
                    tmpvar_361 = bool(1);
                    bool tmpvar_362;
                    vec3 tmpvar_363;
                    tmpvar_363 = (normal_359 * planeOffsets[i_348]);
                    lowp float tmpvar_364;
                    tmpvar_364 = (((
                      (tmpvar_363.x + tmpvar_363.y)
                     + tmpvar_363.z) - dot (normal_359, ray_origin_343)) / dot (normal_359, ray_direction_344));
                    if (((tmpvar_364 < t_hit_345) && (tmpvar_364 > 0.001))) {
                      t_hit_360 = tmpvar_364;
                      tmpvar_362 = bool(1);
                      tmpvar_361 = bool(0);
                    };
                    if (tmpvar_361) {
                      tmpvar_362 = bool(0);
                      tmpvar_361 = bool(0);
                    };
                    t_hit_345 = t_hit_360;
                    if (tmpvar_362) {
                      tmpvar_346 = bool(1);
                      tmpvar_347 = bool(1);
                      break;
                    };
                    i_348++;
                  };
                  if (!(tmpvar_347)) {
                    tmpvar_346 = bool(0);
                    tmpvar_347 = bool(1);
                  };
                };
                if (!(tmpvar_346)) {
                  illuminationColor_333 = (illuminationColor_333 + ((diffuseColor_331 * lightBrightness_340) * (
                    (tmpvar_341 * spotAttenuation_334)
                   * tmpvar_342)));
                };
              };
            };
          };
        };
        indirect_sampling_sum_284 = (indirect_sampling_sum_284 + illuminationColor_333);
      };
      pixelColor_5 = (pixelColor_5 + ((indirect_sampling_sum_284 / 
        float(indirectSamples)
      ) * diffuseColor_12));
    };
  };
  bool tmpvar_365;
  if ((rayBounces > 0)) {
    tmpvar_365 = (sqrt(dot (reflectiveColor_14, reflectiveColor_14)) > 0.0);
  } else {
    tmpvar_365 = bool(0);
  };
  if (tmpvar_365) {
    lowp vec3 P_366;
    P_366 = position_10;
    lowp vec3 V_367;
    V_367 = tmpvar_6;
    lowp vec3 N_368;
    N_368 = normal_11;
    vec3 reflectiveColor_369;
    reflectiveColor_369 = reflectiveColor_14;
    highp int i_370;
    lowp vec3 reflectionSum_371;
    i_370 = 0;
    while (true) {
      lowp vec3 mirror_sample_color_372;
      float roughness2_373;
      vec3 reflective2_374;
      vec3 specular2_375;
      lowp vec3 diffuse2_376;
      if ((i_370 >= rayBounces)) {
        break;
      };
      if ((((reflectiveColor_369.x + reflectiveColor_369.y) + reflectiveColor_369.z) == 0.0)) {
        break;
      };
      lowp vec3 tmpvar_377;
      tmpvar_377 = (V_367 - (2.0 * (
        dot (N_368, V_367)
       * N_368)));
      V_367 = tmpvar_377;
      lowp vec3 ray_origin_378;
      ray_origin_378 = P_366;
      lowp vec3 ray_direction_379;
      ray_direction_379 = tmpvar_377;
      lowp float t_hit_380;
      t_hit_380 = 20.0;
      lowp vec3 position_381;
      lowp vec3 normal_382;
      lowp vec3 diffuseColor_383;
      diffuseColor_383 = diffuse2_376;
      vec3 specularColor_384;
      specularColor_384 = specular2_375;
      vec3 reflectiveColor_385;
      reflectiveColor_385 = reflective2_374;
      float roughness_386;
      roughness_386 = roughness2_373;
      bool intersectLight_387;
      intersectLight_387 = bool(1);
      highp int idx_390;
      highp int intersected_391;
      intersected_391 = 0;
      idx_390 = 0;
      for (highp int i_389 = 0; i_389 < numSpheres; i_389++) {
        lowp float t_hit_392;
        t_hit_392 = t_hit_380;
        bool tmpvar_393;
        lowp vec3 tmpvar_394;
        tmpvar_394 = (sphereCenters[i_389] - ray_origin_378);
        lowp float tmpvar_395;
        tmpvar_395 = dot (tmpvar_394, ray_direction_379);
        if ((tmpvar_395 < 0.0)) {
          tmpvar_393 = bool(0);
        } else {
          lowp float tmpvar_396;
          tmpvar_396 = (dot (tmpvar_394, tmpvar_394) - (tmpvar_395 * tmpvar_395));
          if ((tmpvar_396 > 0.64)) {
            tmpvar_393 = bool(0);
          } else {
            lowp float tmpvar_397;
            tmpvar_397 = sqrt((0.64 - tmpvar_396));
            lowp float tmpvar_398;
            tmpvar_398 = (tmpvar_395 - tmpvar_397);
            lowp float tmpvar_399;
            tmpvar_399 = (tmpvar_395 + tmpvar_397);
            lowp float tmpvar_400;
            if ((tmpvar_398 < 0.01)) {
              tmpvar_400 = tmpvar_399;
            } else {
              tmpvar_400 = tmpvar_398;
            };
            if (((tmpvar_400 < t_hit_380) && (tmpvar_400 > 0.01))) {
              t_hit_392 = tmpvar_400;
              tmpvar_393 = bool(1);
            } else {
              tmpvar_393 = bool(0);
            };
          };
        };
        t_hit_380 = t_hit_392;
        if (tmpvar_393) {
          idx_390 = i_389;
          intersected_391 = 1;
        };
      };
      for (highp int i_388 = 0; i_388 < numPlanes; i_388++) {
        lowp vec3 tmpvar_401;
        tmpvar_401 = planeNormals[i_388];
        bool tmpvar_402;
        if (enablePlaneBacksides) {
          tmpvar_402 = bool(1);
        } else {
          tmpvar_402 = (dot (ray_direction_379, tmpvar_401) < 0.0);
        };
        if (tmpvar_402) {
          lowp float t_hit_403;
          t_hit_403 = t_hit_380;
          bool tmpvar_404;
          tmpvar_404 = bool(1);
          bool tmpvar_405;
          lowp vec3 tmpvar_406;
          tmpvar_406 = (tmpvar_401 * planeOffsets[i_388]);
          lowp float tmpvar_407;
          tmpvar_407 = (((
            (tmpvar_406.x + tmpvar_406.y)
           + tmpvar_406.z) - dot (tmpvar_401, ray_origin_378)) / dot (tmpvar_401, ray_direction_379));
          if (((tmpvar_407 < t_hit_380) && (tmpvar_407 > 0.01))) {
            t_hit_403 = tmpvar_407;
            tmpvar_405 = bool(1);
            tmpvar_404 = bool(0);
          };
          if (tmpvar_404) {
            tmpvar_405 = bool(0);
            tmpvar_404 = bool(0);
          };
          t_hit_380 = t_hit_403;
          if (tmpvar_405) {
            normal_382 = tmpvar_401;
            idx_390 = i_388;
            intersected_391 = 2;
          };
        };
      };
      intersectLight_387 = bool(0);
      for (highp int i_408 = 0; i_408 < numLights; i_408++) {
        bool tmp_409;
        vec3 tmpvar_410;
        tmpvar_410 = lightPos[i_408];
        vec2 tmpvar_411;
        tmpvar_411 = lightSize[i_408];
        tmp_409 = bool(0);
        if (((tmpvar_411.x > 0.0) && (tmpvar_411.y > 0.0))) {
          lowp float t_hit_412;
          t_hit_412 = t_hit_380;
          bool tmpvar_413;
          tmpvar_413 = bool(1);
          bool tmpvar_414;
          vec3 tmpvar_415;
          tmpvar_415 = (vec3(0.0, 1.0, 0.0) * tmpvar_410.y);
          lowp float tmpvar_416;
          tmpvar_416 = (((
            (tmpvar_415.x + tmpvar_415.y)
           + tmpvar_415.z) - ray_origin_378.y) / ray_direction_379.y);
          if (((tmpvar_416 < t_hit_380) && (tmpvar_416 > 0.01))) {
            lowp vec3 tmpvar_417;
            tmpvar_417 = (ray_origin_378 + (ray_direction_379 * tmpvar_416));
            if ((((tmpvar_411.x + tmpvar_411.y) == 0.0) || ((
              ((tmpvar_417.x < (tmpvar_410.x + (tmpvar_411.x * 0.5))) && (tmpvar_417.x > (tmpvar_410.x - (tmpvar_411.x * 0.5))))
             && 
              (tmpvar_417.z < (tmpvar_410.z + (tmpvar_411.y * 0.5)))
            ) && (tmpvar_417.z > 
              (tmpvar_410.z - (tmpvar_411.y * 0.5))
            )))) {
              t_hit_412 = tmpvar_416;
              tmpvar_414 = bool(1);
              tmpvar_413 = bool(0);
            };
          };
          if (tmpvar_413) {
            tmpvar_414 = bool(0);
            tmpvar_413 = bool(0);
          };
          t_hit_380 = t_hit_412;
          tmp_409 = tmpvar_414;
        } else {
          lowp float t_hit_418;
          t_hit_418 = t_hit_380;
          bool tmpvar_419;
          lowp vec3 tmpvar_420;
          tmpvar_420 = (tmpvar_410 - ray_origin_378);
          lowp float tmpvar_421;
          tmpvar_421 = dot (tmpvar_420, ray_direction_379);
          if ((tmpvar_421 < 0.0)) {
            tmpvar_419 = bool(0);
          } else {
            lowp float tmpvar_422;
            tmpvar_422 = (dot (tmpvar_420, tmpvar_420) - (tmpvar_421 * tmpvar_421));
            if ((tmpvar_422 > 0.01)) {
              tmpvar_419 = bool(0);
            } else {
              lowp float tmpvar_423;
              tmpvar_423 = sqrt((0.01 - tmpvar_422));
              lowp float tmpvar_424;
              tmpvar_424 = (tmpvar_421 - tmpvar_423);
              lowp float tmpvar_425;
              tmpvar_425 = (tmpvar_421 + tmpvar_423);
              lowp float tmpvar_426;
              if ((tmpvar_424 < 0.01)) {
                tmpvar_426 = tmpvar_425;
              } else {
                tmpvar_426 = tmpvar_424;
              };
              if (((tmpvar_426 < t_hit_380) && (tmpvar_426 > 0.01))) {
                t_hit_418 = tmpvar_426;
                tmpvar_419 = bool(1);
              } else {
                tmpvar_419 = bool(0);
              };
            };
          };
          t_hit_380 = t_hit_418;
          tmp_409 = tmpvar_419;
        };
        if (tmp_409) {
          idx_390 = i_408;
          intersected_391 = 3;
        };
      };
      position_381 = (P_366 + (tmpvar_377 * t_hit_380));
      if ((intersected_391 == 1)) {
        diffuseColor_383 = sphereColors[idx_390];
        specularColor_384 = sphereSpecColors[idx_390];
        reflectiveColor_385 = reflectiveColors[idx_390];
        roughness_386 = sphereRoughness[idx_390];
        lowp vec3 tmpvar_427;
        tmpvar_427 = normalize((position_381 - sphereCenters[idx_390]));
        normal_382 = tmpvar_427;
        lowp float tmpvar_428;
        tmpvar_428 = dot (tmpvar_427, -(tmpvar_377));
        if ((tmpvar_428 < 0.0)) {
          normal_382 = -(tmpvar_427);
        };
      } else {
        if ((intersected_391 == 2)) {
          if (!(enablePlaneMirrors)) {
            diffuseColor_383 = planeColors[idx_390];
            specularColor_384 = vec3(planeSpecular[idx_390]);
            reflectiveColor_385 = vec3(0.0, 0.0, 0.0);
            roughness_386 = planeRoughness[idx_390];
          } else {
            diffuseColor_383 = (planeColors[idx_390] * 0.01);
            specularColor_384 = vec3(0.0, 0.0, 0.0);
            reflectiveColor_385 = planeColors[idx_390];
            roughness_386 = 1.0;
          };
          lowp float tmpvar_429;
          tmpvar_429 = dot (normal_382, -(tmpvar_377));
          if ((tmpvar_429 < 0.0)) {
            normal_382 = -(normal_382);
          };
        } else {
          if ((intersected_391 == 3)) {
            lowp float spot_falloff_430;
            spot_falloff_430 = 1.0;
            vec2 tmpvar_431;
            tmpvar_431 = lightSpot[idx_390];
            if ((tmpvar_431.x > 0.0)) {
              lowp float tmpvar_432;
              if ((tmpvar_377.y > tmpvar_431.x)) {
                tmpvar_432 = pow (tmpvar_377.y, tmpvar_431.y);
              } else {
                tmpvar_432 = 0.0;
              };
              spot_falloff_430 = tmpvar_432;
            };
            diffuseColor_383 = ((spot_falloff_430 * lightBrightness[idx_390]) * 0.2);
            intersectLight_387 = bool(1);
          };
        };
      };
      N_368 = normal_382;
      diffuse2_376 = diffuseColor_383;
      specular2_375 = specularColor_384;
      reflective2_374 = reflectiveColor_385;
      roughness2_373 = roughness_386;
      lowp vec3 tmpvar_433;
      if (intersectLight_387) {
        tmpvar_433 = diffuseColor_383;
      } else {
        lowp vec3 P_434;
        P_434 = position_381;
        lowp vec3 V_435;
        V_435 = tmpvar_377;
        lowp vec3 N_436;
        N_436 = normal_382;
        lowp vec3 diffuseColor_437;
        diffuseColor_437 = diffuseColor_383;
        vec3 specularColor_438;
        specularColor_438 = specularColor_384;
        highp int i_439;
        lowp vec3 illuminationColor_440;
        i_439 = 0;
        while (true) {
          highp int k_441;
          bool inShade_442;
          highp int areaShadowSamples_443;
          lowp vec3 light_sum_444;
          vec2 lightSpot_445;
          vec2 lightSize_446;
          vec3 lightBrightness_447;
          vec3 lightPos_448;
          if ((i_439 >= numLights)) {
            break;
          };
          lightPos_448 = lightPos[i_439];
          lightBrightness_447 = lightBrightness[i_439];
          lightSize_446 = lightSize[i_439];
          lightSpot_445 = lightSpot[i_439];
          areaShadowSamples_443 = 0;
          inShade_442 = bool(0);
          k_441 = 0;
          while (true) {
            vec3 testPos_449;
            if ((k_441 >= 1)) {
              break;
            };
            if (inShade_442) {
              break;
            };
            testPos_449 = lightPos_448;
            if ((k_441 == 1)) {
              testPos_449.x = (lightPos_448.x - (lightSize_446.x * 0.5));
              testPos_449.z = (lightPos_448.z - (lightSize_446.y * 0.5));
            } else {
              if ((k_441 == 2)) {
                testPos_449.x = (testPos_449.x + (lightSize_446.x * 0.5));
                testPos_449.z = (testPos_449.z + (lightSize_446.y * 0.5));
              } else {
                if ((k_441 == 3)) {
                  testPos_449.x = (testPos_449.x + (lightSize_446.x * 0.5));
                  testPos_449.z = (testPos_449.z - (lightSize_446.y * 0.5));
                } else {
                  if ((k_441 == 4)) {
                    testPos_449.x = (testPos_449.x - (lightSize_446.x * 0.5));
                    testPos_449.z = (testPos_449.z + (lightSize_446.y * 0.5));
                  };
                };
              };
            };
            lowp vec3 L_450;
            lowp vec3 incidentIntensity_451;
            lowp float falloff_452;
            L_450 = (testPos_449 - P_434);
            lowp float tmpvar_453;
            tmpvar_453 = sqrt(dot (L_450, L_450));
            lowp float tmpvar_454;
            tmpvar_454 = (1.0/(((attenuationFactor.x * 
              (tmpvar_453 * tmpvar_453)
            ) + (attenuationFactor.y * tmpvar_453))));
            lowp vec3 tmpvar_455;
            tmpvar_455 = normalize(L_450);
            L_450 = tmpvar_455;
            falloff_452 = 1.0;
            if ((lightSpot_445.x > 0.0)) {
              lowp float tmpvar_456;
              if ((tmpvar_455.y > lightSpot_445.x)) {
                tmpvar_456 = pow (tmpvar_455.y, lightSpot_445.y);
              } else {
                tmpvar_456 = 0.0;
              };
              falloff_452 = tmpvar_456;
            };
            incidentIntensity_451 = ((lightBrightness_447 * tmpvar_454) * falloff_452);
            lowp float tmpvar_457;
            tmpvar_457 = dot (N_436, tmpvar_455);
            if (((tmpvar_457 > 0.0) && ((
              (incidentIntensity_451.x + incidentIntensity_451.y)
             + incidentIntensity_451.z) > 0.01))) {
              lowp vec3 ray_origin_458;
              ray_origin_458 = P_434;
              lowp vec3 ray_direction_459;
              ray_direction_459 = tmpvar_455;
              lowp float t_hit_460;
              t_hit_460 = tmpvar_453;
              bool tmpvar_461;
              tmpvar_461 = bool(0);
              highp int i_462;
              highp int i_463;
              i_463 = 0;
              while (true) {
                if ((i_463 >= numSpheres)) {
                  break;
                };
                lowp float t_hit_464;
                t_hit_464 = t_hit_460;
                bool tmpvar_465;
                lowp vec3 tmpvar_466;
                tmpvar_466 = (sphereCenters[i_463] - ray_origin_458);
                lowp float tmpvar_467;
                tmpvar_467 = dot (tmpvar_466, ray_direction_459);
                if ((tmpvar_467 < 0.0)) {
                  tmpvar_465 = bool(0);
                } else {
                  lowp float tmpvar_468;
                  tmpvar_468 = (dot (tmpvar_466, tmpvar_466) - (tmpvar_467 * tmpvar_467));
                  if ((tmpvar_468 > 0.64)) {
                    tmpvar_465 = bool(0);
                  } else {
                    lowp float tmpvar_469;
                    tmpvar_469 = sqrt((0.64 - tmpvar_468));
                    lowp float tmpvar_470;
                    tmpvar_470 = (tmpvar_467 - tmpvar_469);
                    lowp float tmpvar_471;
                    tmpvar_471 = (tmpvar_467 + tmpvar_469);
                    lowp float tmpvar_472;
                    if ((tmpvar_470 < 0.001)) {
                      tmpvar_472 = tmpvar_471;
                    } else {
                      tmpvar_472 = tmpvar_470;
                    };
                    if (((tmpvar_472 < t_hit_460) && (tmpvar_472 > 0.001))) {
                      t_hit_464 = tmpvar_472;
                      tmpvar_465 = bool(1);
                    } else {
                      tmpvar_465 = bool(0);
                    };
                  };
                };
                t_hit_460 = t_hit_464;
                if (tmpvar_465) {
                  tmpvar_461 = bool(1);
                  break;
                };
                i_463++;
              };
              if (!(tmpvar_461)) {
                i_462 = 0;
                while (true) {
                  if ((i_462 >= numPlanes)) {
                    break;
                  };
                  vec3 normal_473;
                  normal_473 = planeNormals[i_462];
                  lowp float t_hit_474;
                  t_hit_474 = t_hit_460;
                  bool tmpvar_475;
                  tmpvar_475 = bool(1);
                  bool tmpvar_476;
                  vec3 tmpvar_477;
                  tmpvar_477 = (normal_473 * planeOffsets[i_462]);
                  lowp float tmpvar_478;
                  tmpvar_478 = (((
                    (tmpvar_477.x + tmpvar_477.y)
                   + tmpvar_477.z) - dot (normal_473, ray_origin_458)) / dot (normal_473, ray_direction_459));
                  if (((tmpvar_478 < t_hit_460) && (tmpvar_478 > 0.001))) {
                    t_hit_474 = tmpvar_478;
                    tmpvar_476 = bool(1);
                    tmpvar_475 = bool(0);
                  };
                  if (tmpvar_475) {
                    tmpvar_476 = bool(0);
                    tmpvar_475 = bool(0);
                  };
                  t_hit_460 = t_hit_474;
                  if (tmpvar_476) {
                    tmpvar_461 = bool(1);
                    break;
                  };
                  i_462++;
                };
                if (!(tmpvar_461)) {
                  tmpvar_461 = bool(1);
                };
              };
              lowp float tmpvar_479;
              tmpvar_479 = abs((t_hit_460 - tmpvar_453));
              if ((tmpvar_479 < 0.001)) {
                lowp vec3 I_480;
                I_480 = -(tmpvar_455);
                light_sum_444 = (light_sum_444 + (incidentIntensity_451 * (
                  (diffuseColor_437 * dot (N_436, tmpvar_455))
                 + 
                  (specularColor_438 * pow (max (0.0, dot (
                    (I_480 - (2.0 * (dot (N_436, I_480) * N_436)))
                  , 
                    -(V_435)
                  )), 128.0))
                )));
              } else {
                inShade_442 = bool(1);
              };
            } else {
              inShade_442 = bool(1);
            };
            areaShadowSamples_443++;
            k_441++;
          };
          illuminationColor_440 = (illuminationColor_440 + (light_sum_444 / float(areaShadowSamples_443)));
          i_439++;
        };
        tmpvar_433 = illuminationColor_440;
      };
      mirror_sample_color_372 = tmpvar_433;
      if (enableRefGI) {
        lowp vec3 P_481;
        P_481 = position_381;
        lowp vec3 N_482;
        N_482 = normal_382;
        highp int i_483;
        lowp vec3 indirect_sampling_sum_484;
        i_483 = 0;
        while (true) {
          float roughness2_485;
          vec3 reflective2_486;
          vec3 specular2_487;
          lowp vec3 diffuse2_488;
          if ((i_483 >= indirectSamples)) {
            break;
          };
          float sampleIdx_489;
          sampleIdx_489 = float(i_483);
          randomIncrement += 0.02;
          lowp float tmpvar_490;
          tmpvar_490 = ((1.0 - (
            (sampleIdx_489 / float((indirectSamples - 1)))
           * 2.0)) + ((
            fract((cos(dot (
              (P_481.xy + randomIncrement)
            , vec2(23.14069, 2.665144))) * 12345.68))
           * 0.4) - 0.2));
          lowp float tmpvar_491;
          tmpvar_491 = sqrt((1.0 - (tmpvar_490 * tmpvar_490)));
          randomIncrement += 0.02;
          lowp float tmpvar_492;
          tmpvar_492 = ((2.399963 * sampleIdx_489) + ((
            fract((cos(dot (
              (P_481.xy + randomIncrement)
            , vec2(23.14069, 2.665144))) * 12345.68))
           * 0.5) - 0.25));
          lowp vec3 tmpvar_493;
          tmpvar_493.x = (cos(tmpvar_492) * tmpvar_491);
          tmpvar_493.y = tmpvar_490;
          tmpvar_493.z = (sin(tmpvar_492) * tmpvar_491);
          lowp vec3 ray_origin_494;
          ray_origin_494 = P_481;
          lowp vec3 ray_direction_495;
          ray_direction_495 = normalize(normalize((N_482 + tmpvar_493)));
          lowp float t_hit_496;
          t_hit_496 = 10.0;
          lowp vec3 position_497;
          lowp vec3 normal_498;
          lowp vec3 diffuseColor_499;
          diffuseColor_499 = diffuse2_488;
          vec3 specularColor_500;
          specularColor_500 = specular2_487;
          vec3 reflectiveColor_501;
          reflectiveColor_501 = reflective2_486;
          float roughness_502;
          roughness_502 = roughness2_485;
          highp int i_503;
          highp int i_504;
          highp int idx_505;
          highp int intersected_506;
          intersected_506 = 0;
          idx_505 = 0;
          i_504 = 0;
          while (true) {
            if ((i_504 >= numSpheres)) {
              break;
            };
            lowp float t_hit_507;
            t_hit_507 = t_hit_496;
            bool tmpvar_508;
            lowp vec3 tmpvar_509;
            tmpvar_509 = (sphereCenters[i_504] - ray_origin_494);
            lowp float tmpvar_510;
            tmpvar_510 = dot (tmpvar_509, ray_direction_495);
            if ((tmpvar_510 < 0.0)) {
              tmpvar_508 = bool(0);
            } else {
              lowp float tmpvar_511;
              tmpvar_511 = (dot (tmpvar_509, tmpvar_509) - (tmpvar_510 * tmpvar_510));
              if ((tmpvar_511 > 0.64)) {
                tmpvar_508 = bool(0);
              } else {
                lowp float tmpvar_512;
                tmpvar_512 = sqrt((0.64 - tmpvar_511));
                lowp float tmpvar_513;
                tmpvar_513 = (tmpvar_510 - tmpvar_512);
                lowp float tmpvar_514;
                tmpvar_514 = (tmpvar_510 + tmpvar_512);
                lowp float tmpvar_515;
                if ((tmpvar_513 < 0.01)) {
                  tmpvar_515 = tmpvar_514;
                } else {
                  tmpvar_515 = tmpvar_513;
                };
                if (((tmpvar_515 < t_hit_496) && (tmpvar_515 > 0.01))) {
                  t_hit_507 = tmpvar_515;
                  tmpvar_508 = bool(1);
                } else {
                  tmpvar_508 = bool(0);
                };
              };
            };
            t_hit_496 = t_hit_507;
            if (tmpvar_508) {
              idx_505 = i_504;
              intersected_506 = 1;
            };
            i_504++;
          };
          i_503 = 0;
          while (true) {
            if ((i_503 >= numPlanes)) {
              break;
            };
            lowp vec3 tmpvar_516;
            tmpvar_516 = planeNormals[i_503];
            bool tmpvar_517;
            if (enablePlaneBacksides) {
              tmpvar_517 = bool(1);
            } else {
              tmpvar_517 = (dot (ray_direction_495, tmpvar_516) < 0.0);
            };
            if (tmpvar_517) {
              lowp float t_hit_518;
              t_hit_518 = t_hit_496;
              bool tmpvar_519;
              tmpvar_519 = bool(1);
              bool tmpvar_520;
              lowp vec3 tmpvar_521;
              tmpvar_521 = (tmpvar_516 * planeOffsets[i_503]);
              lowp float tmpvar_522;
              tmpvar_522 = (((
                (tmpvar_521.x + tmpvar_521.y)
               + tmpvar_521.z) - dot (tmpvar_516, ray_origin_494)) / dot (tmpvar_516, ray_direction_495));
              if (((tmpvar_522 < t_hit_496) && (tmpvar_522 > 0.01))) {
                t_hit_518 = tmpvar_522;
                tmpvar_520 = bool(1);
                tmpvar_519 = bool(0);
              };
              if (tmpvar_519) {
                tmpvar_520 = bool(0);
                tmpvar_519 = bool(0);
              };
              t_hit_496 = t_hit_518;
              if (tmpvar_520) {
                normal_498 = tmpvar_516;
                idx_505 = i_503;
                intersected_506 = 2;
              };
            };
            i_503++;
          };
          position_497 = (P_481 + (ray_direction_495 * t_hit_496));
          if ((intersected_506 == 1)) {
            diffuseColor_499 = sphereColors[idx_505];
            specularColor_500 = sphereSpecColors[idx_505];
            reflectiveColor_501 = reflectiveColors[idx_505];
            roughness_502 = sphereRoughness[idx_505];
            lowp vec3 tmpvar_523;
            tmpvar_523 = normalize((position_497 - sphereCenters[idx_505]));
            normal_498 = tmpvar_523;
            lowp float tmpvar_524;
            tmpvar_524 = dot (tmpvar_523, -(ray_direction_495));
            if ((tmpvar_524 < 0.0)) {
              normal_498 = -(tmpvar_523);
            };
          } else {
            if ((intersected_506 == 2)) {
              if (!(enablePlaneMirrors)) {
                diffuseColor_499 = planeColors[idx_505];
                specularColor_500 = vec3(planeSpecular[idx_505]);
                reflectiveColor_501 = vec3(0.0, 0.0, 0.0);
                roughness_502 = planeRoughness[idx_505];
              } else {
                diffuseColor_499 = (planeColors[idx_505] * 0.01);
                specularColor_500 = vec3(0.0, 0.0, 0.0);
                reflectiveColor_501 = planeColors[idx_505];
                roughness_502 = 1.0;
              };
              lowp float tmpvar_525;
              tmpvar_525 = dot (normal_498, -(ray_direction_495));
              if ((tmpvar_525 < 0.0)) {
                normal_498 = -(normal_498);
              };
            } else {
              if ((intersected_506 == 3)) {
                lowp float spot_falloff_526;
                spot_falloff_526 = 1.0;
                vec2 tmpvar_527;
                tmpvar_527 = lightSpot[idx_505];
                if ((tmpvar_527.x > 0.0)) {
                  lowp float tmpvar_528;
                  if ((ray_direction_495.y > tmpvar_527.x)) {
                    tmpvar_528 = pow (ray_direction_495.y, tmpvar_527.y);
                  } else {
                    tmpvar_528 = 0.0;
                  };
                  spot_falloff_526 = tmpvar_528;
                };
                diffuseColor_499 = ((spot_falloff_526 * lightBrightness[idx_505]) * 0.2);
              };
            };
          };
          diffuse2_488 = diffuseColor_499;
          specular2_487 = specularColor_500;
          reflective2_486 = reflectiveColor_501;
          roughness2_485 = roughness_502;
          lowp vec3 P_529;
          P_529 = position_497;
          lowp vec3 N_530;
          N_530 = normal_498;
          lowp vec3 diffuseColor_531;
          diffuseColor_531 = (diffuseColor_499 + reflectiveColor_501);
          highp int i_532;
          lowp vec3 illuminationColor_533;
          i_532 = 0;
          while (true) {
            lowp float spotAttenuation_534;
            if ((i_532 >= numLights)) {
              break;
            };
            lowp vec3 tmpvar_535;
            tmpvar_535 = (lightPos[i_532] - P_529);
            lowp float tmpvar_536;
            tmpvar_536 = sqrt(dot (tmpvar_535, tmpvar_535));
            lowp vec3 tmpvar_537;
            tmpvar_537 = normalize(tmpvar_535);
            vec2 tmpvar_538;
            tmpvar_538 = lightSpot[i_532];
            spotAttenuation_534 = 1.0;
            if ((tmpvar_538.x > 0.0)) {
              lowp float tmpvar_539;
              if ((tmpvar_537.y > tmpvar_538.x)) {
                tmpvar_539 = pow (tmpvar_537.y, tmpvar_538.y);
              } else {
                tmpvar_539 = 0.0;
              };
              spotAttenuation_534 = tmpvar_539;
            };
            if ((spotAttenuation_534 > 0.0)) {
              vec3 lightBrightness_540;
              lightBrightness_540 = lightBrightness[i_532];
              lowp float tmpvar_541;
              tmpvar_541 = (1.0/(((attenuationFactor.x * 
                (tmpvar_536 * tmpvar_536)
              ) + (attenuationFactor.y * tmpvar_536))));
              if ((tmpvar_541 > 0.004)) {
                lowp float tmpvar_542;
                tmpvar_542 = dot (N_530, tmpvar_537);
                if ((tmpvar_542 > 0.0)) {
                  lowp vec3 ray_origin_543;
                  ray_origin_543 = P_529;
                  lowp vec3 ray_direction_544;
                  ray_direction_544 = tmpvar_537;
                  lowp float t_hit_545;
                  t_hit_545 = tmpvar_536;
                  bool tmpvar_546;
                  bool tmpvar_547;
                  tmpvar_547 = bool(0);
                  highp int i_548;
                  highp int i_549;
                  i_549 = 0;
                  while (true) {
                    if ((i_549 >= numSpheres)) {
                      break;
                    };
                    lowp float t_hit_550;
                    t_hit_550 = t_hit_545;
                    bool tmpvar_551;
                    lowp vec3 tmpvar_552;
                    tmpvar_552 = (sphereCenters[i_549] - ray_origin_543);
                    lowp float tmpvar_553;
                    tmpvar_553 = dot (tmpvar_552, ray_direction_544);
                    if ((tmpvar_553 < 0.0)) {
                      tmpvar_551 = bool(0);
                    } else {
                      lowp float tmpvar_554;
                      tmpvar_554 = (dot (tmpvar_552, tmpvar_552) - (tmpvar_553 * tmpvar_553));
                      if ((tmpvar_554 > 0.64)) {
                        tmpvar_551 = bool(0);
                      } else {
                        lowp float tmpvar_555;
                        tmpvar_555 = sqrt((0.64 - tmpvar_554));
                        lowp float tmpvar_556;
                        tmpvar_556 = (tmpvar_553 - tmpvar_555);
                        lowp float tmpvar_557;
                        tmpvar_557 = (tmpvar_553 + tmpvar_555);
                        lowp float tmpvar_558;
                        if ((tmpvar_556 < 0.001)) {
                          tmpvar_558 = tmpvar_557;
                        } else {
                          tmpvar_558 = tmpvar_556;
                        };
                        if (((tmpvar_558 < t_hit_545) && (tmpvar_558 > 0.001))) {
                          t_hit_550 = tmpvar_558;
                          tmpvar_551 = bool(1);
                        } else {
                          tmpvar_551 = bool(0);
                        };
                      };
                    };
                    t_hit_545 = t_hit_550;
                    if (tmpvar_551) {
                      tmpvar_546 = bool(1);
                      tmpvar_547 = bool(1);
                      break;
                    };
                    i_549++;
                  };
                  if (!(tmpvar_547)) {
                    i_548 = 0;
                    while (true) {
                      if ((i_548 >= numPlanes)) {
                        break;
                      };
                      vec3 normal_559;
                      normal_559 = planeNormals[i_548];
                      lowp float t_hit_560;
                      t_hit_560 = t_hit_545;
                      bool tmpvar_561;
                      tmpvar_561 = bool(1);
                      bool tmpvar_562;
                      vec3 tmpvar_563;
                      tmpvar_563 = (normal_559 * planeOffsets[i_548]);
                      lowp float tmpvar_564;
                      tmpvar_564 = (((
                        (tmpvar_563.x + tmpvar_563.y)
                       + tmpvar_563.z) - dot (normal_559, ray_origin_543)) / dot (normal_559, ray_direction_544));
                      if (((tmpvar_564 < t_hit_545) && (tmpvar_564 > 0.001))) {
                        t_hit_560 = tmpvar_564;
                        tmpvar_562 = bool(1);
                        tmpvar_561 = bool(0);
                      };
                      if (tmpvar_561) {
                        tmpvar_562 = bool(0);
                        tmpvar_561 = bool(0);
                      };
                      t_hit_545 = t_hit_560;
                      if (tmpvar_562) {
                        tmpvar_546 = bool(1);
                        tmpvar_547 = bool(1);
                        break;
                      };
                      i_548++;
                    };
                    if (!(tmpvar_547)) {
                      tmpvar_546 = bool(0);
                      tmpvar_547 = bool(1);
                    };
                  };
                  if (!(tmpvar_546)) {
                    illuminationColor_533 = (illuminationColor_533 + ((diffuseColor_531 * lightBrightness_540) * (
                      (tmpvar_541 * spotAttenuation_534)
                     * tmpvar_542)));
                  };
                };
              };
            };
            i_532++;
          };
          indirect_sampling_sum_484 = (indirect_sampling_sum_484 + illuminationColor_533);
          i_483++;
        };
        mirror_sample_color_372 = (tmpvar_433 + ((indirect_sampling_sum_484 / 
          float(indirectSamples)
        ) * diffuseColor_383));
      } else {
        mirror_sample_color_372 = (mirror_sample_color_372 + (ambientLight * diffuseColor_383));
      };
      P_366 = position_381;
      reflectionSum_371 = (reflectionSum_371 + (mirror_sample_color_372 * reflectiveColor_369));
      reflectiveColor_369 = (reflectiveColor_385 * reflectiveColor_369);
      i_370++;
    };
    pixelColor_5 = (pixelColor_5 + reflectionSum_371);
  };
  lowp vec3 x_565;
  x_565 = (mat3(0.59719, 0.076, 0.0284, 0.35458, 0.90834, 0.13383, 0.04823, 0.01566, 0.83777) * pixelColor_5);
  x_565 = (((x_565 * 
    (x_565 + 0.0245786)
  ) - 9.0537e-05) / ((x_565 * 
    ((0.983729 * x_565) + 0.432951)
  ) + 0.238081));
  x_565 = (mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276, -0.07367, -0.00605, 1.07602) * x_565);
  lowp vec3 tmpvar_566;
  tmpvar_566 = clamp (x_565, 0.0, 1.0);
  pixelColor_5 = tmpvar_566;
  lowp vec3 tmpvar_567;
  tmpvar_567 = pow (tmpvar_566, vec3(0.4545454, 0.4545454, 0.4545454));
  float tmpvar_568;
  if ((tmpvar_566.x < 0.0031308)) {
    tmpvar_568 = 1.0;
  } else {
    tmpvar_568 = 0.0;
  };
  float tmpvar_569;
  if ((tmpvar_566.y < 0.0031308)) {
    tmpvar_569 = 1.0;
  } else {
    tmpvar_569 = 0.0;
  };
  float tmpvar_570;
  if ((tmpvar_566.z < 0.0031308)) {
    tmpvar_570 = 1.0;
  } else {
    tmpvar_570 = 0.0;
  };
  vec3 tmpvar_571;
  tmpvar_571.x = tmpvar_568;
  tmpvar_571.y = tmpvar_569;
  tmpvar_571.z = tmpvar_570;
  lowp vec3 tmpvar_572;
  tmpvar_572 = mix (((tmpvar_567 * 1.055) - 0.055), (tmpvar_566 * 12.92), tmpvar_571);
  pixelColor_5 = tmpvar_572;
  lowp vec4 tmpvar_573;
  tmpvar_573.w = 1.0;
  tmpvar_573.xyz = tmpvar_572;
  fragColor = tmpvar_573;
}


        </script>
        <script src="webgl-utils.js"></script>
        <script src='gl-matrix-min.js'></script>
        <script src='world-state.js'></script>
        <script src='raytracer.js'></script>
    </body>
</html>