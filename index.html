<html>
    <head>
        <link rel="stylesheet" href="styles.css" type="text/css">
    </head>

    <body style="background-color: rgb(40, 40, 40);">
        <canvas id="c" width="1800" height="900"></canvas>
        <div id="fps-container"><span id="fps"></span> FPS</div>
        <div class="controls">
            <div class="section">
                <h3>About</h3>
                <p>Use WASD -keys to move around and use mouse while holding mousebutton to look around.</p>
                <p>Check out the <a href="https://github.com/jassenousiainen/webgl-raytracer">repository</a></p>
            </div>
            <div class="section">
                <h3>Rendering settings</h3>
                Select shader:
                <input type="radio" id="fast" name="shader-select" class="shader-select" checked>
                <label for="fast">fast</label>
                <input type="radio" id="quality" name="shader-select" class="shader-select">
                <label for="quality">quality</label>
                <br><br>
                <label class='switch'>
                    <input type="checkbox" id="enableGI">
                    <span class='slider'></span>
                    Indirect lighting
                </label>
                <br>
                <label class='switch'>
                    <input type="checkbox" id="enableRefGI">
                    <span class='slider'></span>
                    Indirect in reflections
                </label>
                <br><br>
                number of indirect samples:
                <br>
                <div class="slider_container">
                    <input type="range" value="50" id="indirectsamples" min="1" max="100" oninput="this.nextElementSibling.value = this.value">
                    <output>50</output>
                </div>
                <br>
                number of direct samples:
                <br>
                <div class="slider_container">
                    <input type="range" list="tickmarks" value="9" id="shadowsamples" min="1" max="25" oninput="this.nextElementSibling.value = this.value">
                    <output>9</output>
                </div>
                <datalist id="tickmarks">
                    <option value="1" label="1"></option>
                    <option value="4" label="4"></option>
                    <option value="9" label="9"></option>
                    <option value="16" label="16"></option>
                    <option value="25" label="25"></option>
                </datalist>
                <br>
                reflection bounces:
                <br>
                <div class="slider_container">
                    <input type="range" value="3" id="reflectionbounces" min="0" max="5" step="1" oninput="this.nextElementSibling.value = this.value">
                    <output>3</output>
                </div>
            </div>
            <div class="section" id="lightcontrols">
                <h3>Lights</h3>
                <label class='switch'>
                    <input type="checkbox" id="arealightsenable" checked>
                    <span class='slider'></span>
                    Area lights on/off
                </label>
                <br><br>
                Attenuation:<br>
                <input type="range" min="0" max="10" step="0.01" value="1.5" id="quadratic" class="attenuation"> Quadratic
                <input type="range" min="0" max="10" step="0.01" value="0" id="linear" class="attenuation"> Linear
                <br>
            </div>
            <div class="section" id="planecontrols">
                <h3>Planes</h3>
                <input type="checkbox" id="planebacksides" checked> Intersect backsides
                <br><br>
            </div>
            <div class="section">
                <h3>Extras</h3>
                <input type="checkbox" id="enablemirrorworld"> Mirror world
                <br>
            </div>
        </div>

        <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
            precision highp float;
            uniform mat4 invprojview;
            uniform float near;
            uniform float far;
            
            out lowp vec3 origin;
            out lowp vec3 ray;
            
            void main() {
                // https://rauwendaal.net/2014/06/14/rendering-a-screen-covering-triangle-in-opengl/
                float x = -1.0 + float((gl_VertexID & 1) << 2);
                float y = -1.0 + float((gl_VertexID & 2) << 1);
                gl_Position = vec4(x, y, 0, 1);
                            
                // https://stackoverflow.com/a/52764898
                origin = (invprojview * vec4(x, y, -1.0, 1.0) * near).xyz;
                ray = (invprojview * vec4(vec2(x,y) * (far - near), far + near, far - near)).xyz;
            }
        </script>
        <!-- Fragment GLSL optimized with: https://zz85.github.io/glsl-optimizer/ -->
        <script id="fragment-shader-quality" type="x-shader/x-fragment">#version 300 es
            precision mediump float;
            
            #define MAX_LIGHTS 2
            #define MAX_SPHERES 5
            #define MAX_PLANES 6
            #define MAX_SHADOW_SAMPLES 25
            #define MAX_RAYBOUNCES 5
            #define MAX_GISAMPLES 100
            
            #define specular_exponent 32.0
            #define EPSILON 0.001
            #define PI 3.141593
            #define PI2 6.283185
            
            const mat3 ACESInputMat = mat3(
                0.59719, 0.07600, 0.02840,
                0.35458, 0.90834, 0.13383,
                0.04823, 0.01566, 0.83777);
            const mat3 ACESOutputMat = mat3(
                1.60475, -0.10208, -0.00327,
                -0.53108,  1.10813, -0.07276,
                -0.07367, -0.00605,  1.07602);
            
            float randomIncrement;
            uniform float randomseed;
            uniform int numLights;
            uniform vec3 lightPos[MAX_LIGHTS];
            uniform vec2 lightSize[MAX_LIGHTS];
            uniform vec3 lightIntensity[MAX_LIGHTS];
            uniform vec2 lightSpot[MAX_LIGHTS];
            uniform int shadowSamples;
            uniform float shadowDim;
            uniform vec2 attenuation;
            
            uniform int numSpheres;
            uniform vec3 sphereCenters[MAX_SPHERES];
            uniform vec3 sphereColors[MAX_SPHERES];
            uniform vec3 reflectiveColors[MAX_SPHERES];
            uniform vec3 sphereSpecColors[MAX_SPHERES];
            uniform float sphereRoughness[MAX_SPHERES];
            
            uniform int numPlanes;
            uniform float planeOffsets[MAX_PLANES];
            uniform vec3 planeNormals[MAX_PLANES];
            uniform vec3 planeColors[MAX_PLANES];
            uniform float planeRoughness[MAX_PLANES];
            
            uniform int rayBounces;
            uniform vec3 ambientLight;
            uniform bool enableGI;
            uniform bool enableRefGI;
            uniform int indirectSamples;
            uniform bool enablePlaneBacksides;
            uniform bool enablePlaneMirrors;
            
            in lowp vec3 origin;
            in lowp vec3 ray;
            out vec4 fragColor;
            
            
            // https://stackoverflow.com/a/10625698
            float random( vec2 p ) {
                vec2 K1 = vec2(
                    23.14069263277926, // e^pi (Gelfond's constant)
                     2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)
                );
                randomIncrement += 0.02; // increment, so that each access gets different value
                return fract( cos( dot(p+randomIncrement,K1) ) * 12345.6789 );
            }
            
            bool intersectSphere(vec3 ray_origin, vec3 ray_direction, vec3 center, float radius, float tmin, inout float t_hit) {
                float radius_sqr = radius*radius;
                vec3 vec_to_orig = center - ray_origin; 
            
                float t_closest = dot(vec_to_orig , ray_direction); // t at the closest to the sphere's center
                if (t_closest < 0.0) // If negative, the ray and sphere are on other sides of the origin
                    return false; 
            
                float dist_to_center2 = dot(vec_to_orig, vec_to_orig) - t_closest * t_closest;
                if (dist_to_center2 > radius_sqr) // If the smallest distance^2 from the ray to center is larger that radius^2, the ray doesn't intersect
                    return false; 
            
                float dist_mid_to_surface = sqrt(radius_sqr - dist_to_center2); 
                float t_surface1 = t_closest - dist_mid_to_surface; // t values at surfaces on both sides
                float t_surface2 = t_closest + dist_mid_to_surface;
            
                float t = (t_surface1 < tmin) ? t_surface2 : t_surface1;
                if (t < t_hit && t > tmin) {
                    t_hit = t;
                    return true;
                }
                return false;
            }
            
            bool intersectPlane(vec3 ray_origin, vec3 ray_direction, float offset, vec3 normal, vec3 center, vec2 size, float tmin, inout float t_hit) {
                vec3 normal_offset = normal * offset;
                float d = normal_offset.x + normal_offset.y + normal_offset.z;
                float t = (d - dot(normal, ray_origin)) / dot(normal, ray_direction);
                
                if (t < t_hit && t > tmin) {
                    vec3 tmpPos = ray_origin + ray_direction * t;
                    if (length(size) == 0.0 || (
                        tmpPos.x < center.x + size.x*0.5 &&
                        tmpPos.x > center.x - size.x*0.5 &&
                        tmpPos.z < center.z + size.y*0.5 &&
                        tmpPos.z > center.z - size.y*0.5)) {
                        t_hit = t;
                        return true;
                    }
                }
                return false;
            }
            
            // Intersects with all of the objects in the world and returns closest hit (note the use of "out" arguments)
            bool intersect(vec3 ray_origin,
                        vec3 ray_direction,
                        inout float t_hit,
                        float tmin,
                        out vec3 position,
                        out vec3 normal,
                        inout vec3 diffuseColor,
                        inout vec3 specularColor,
                        inout vec3 reflectiveColor,
                        inout float roughness,
                        inout bool isLight)
            {
                int intersected = 0;
                int idx = 0;
                
                // Intersect spheres
                for (int i = 0; i < MAX_SPHERES; i++) {
                    if (i >= numSpheres) break;
                    if (intersectSphere(ray_origin, ray_direction, sphereCenters[i], 0.8, tmin, t_hit)) {
                        idx = i;
                        intersected = 1;
                    }
                }
            
                // Intersect planes
                for (int i = 0; i < MAX_PLANES; i++) {
                    if (i >= numPlanes) break;
                    vec3 planeNormal = planeNormals[i];
                    bool tmp = false;
                    if (enablePlaneBacksides || dot(ray_direction, planeNormal) < 0.0)
                        tmp = intersectPlane(ray_origin, ray_direction, planeOffsets[i], planeNormal, vec3(0,0,0), vec2(0,0), tmin, t_hit);
                    if (tmp) {
                        normal = planeNormal;
                        idx = i;
                        intersected = 2;
                    }
                }
            
                // Intersect lights to make them visible
                for (int i = 0; i < MAX_LIGHTS; i++) {
                    if (i >= numLights) break;
                    vec3 center = lightPos[i];
                    vec2 size = lightSize[i];
                    bool tmp = false;
                    if (size.x > 0.0 && size.y > 0.0)
                        tmp = intersectPlane(ray_origin, ray_direction, center.y, vec3(0,1,0), center, size, tmin, t_hit);
                    else
                        tmp = intersectSphere(ray_origin, ray_direction, center, 0.1, tmin, t_hit);
                    if (tmp) {
                        idx = i;
                        intersected = 3;
                    }
                }
            
                position = ray_origin + ray_direction * t_hit;
            
                // Make only one color lookup for each intersection
                 if (intersected == 1) {
                    diffuseColor = sphereColors[idx];
                    specularColor = sphereSpecColors[idx];
                    reflectiveColor = reflectiveColors[idx];
                    roughness = sphereRoughness[idx];
                    normal = normalize(position - sphereCenters[idx]);
                    if (dot(normal, -ray_direction) < 0.0) // Backside shading: flip normal if ray and normal are on different sides
                        normal *= -1.0;
                }
                else if (intersected == 2) {
                    if (enablePlaneMirrors) {
                        diffuseColor = planeColors[idx]*0.01;
                        specularColor = vec3(0, 0, 0);
                        reflectiveColor = planeColors[idx];
                        roughness = 1.0;
                    } else {
                        diffuseColor = planeColors[idx];
                        specularColor = vec3(0, 0, 0);
                        reflectiveColor = vec3(0, 0, 0);
                        roughness = planeRoughness[idx];
                    }
                    if (dot(normal, -ray_direction) < 0.0) // Backside shading: flip normal if ray and normal are on different sides
                        normal *= -1.0;
                }
                else if (intersected == 3) {
                    diffuseColor = lightIntensity[idx]/25.0;
                    isLight = true;
                }
            
                return intersected != 0;
            }
            
            // Faster intersect function for shadows
            bool intersectShadowRay(vec3 ray_origin, vec3 ray_direction, inout float t_hit, float tmin) {
                for (int i = 0; i < MAX_SPHERES; i++) {
                    if (i == numSpheres) break;
                    if (intersectSphere(ray_origin, ray_direction, sphereCenters[i], 0.8, tmin, t_hit))
                        return true;
                }
                for (int i = 0; i < MAX_PLANES; i++) {
                    if (i == numPlanes) break;
                    if (intersectPlane(ray_origin, ray_direction, planeOffsets[i], planeNormals[i], vec3(0,0,0), vec2(0,0), tmin, t_hit))
                        return true;
                }
                return false;
            }
            
            void getIncidentIntensity(float sample_i, vec3 p, vec3 position, vec3 intensity, vec2 size, vec2 spot, out float light_distance, out vec3 vec_to_light, out vec3 incident_intensity) {
                if (size.x > 0.0 && size.y > 0.0) {
                    // Get jittered position on the light plane
                    float inv_dim = 1.0 / shadowDim;
                    float cell_sizeX = size.x * inv_dim;
                    float cell_sizeY = size.y * inv_dim;
                    float posX = cell_sizeX * (mod(sample_i, shadowDim) + random(p.xy));
                    float posY = cell_sizeY * (floor(sample_i * inv_dim) + random(p.yx));
                    float x = position.x - size.x*0.5 + posX;
                    float z = position.z - size.y*0.5 + posY;
                    vec_to_light = vec3(x, position.y, z) - p;
                } else {
                    vec_to_light = position - p; // point light
                }
            
                light_distance = length(vec_to_light);
                float attenuation = 1.0 / (attenuation.x*pow(light_distance, 2.0) + attenuation.y*light_distance);
                vec_to_light = normalize(vec_to_light);
            
                // Spotlight effect
                // spot.x is the size of the spot and spot.y is the exponent to produce smooth falloff
                float spot_falloff = 1.0;
                if (spot.x > 0.0) {
                    float dot_to_light = dot(vec_to_light, vec3(0.0, 1.0, 0.0));
                    spot_falloff = (dot_to_light > spot.x) ? pow(dot_to_light, spot.y) : 0.0;
                }
            
                incident_intensity = intensity * attenuation * spot_falloff;
            }
            
            vec3 shadePhong(vec3 ray_direction, vec3 normal, vec3 dir_to_light, vec3 incident_intensity, vec3 diffuse_color, vec3 specular_color) {        
                if (dot(normal, dir_to_light) > 0.0) {                                                  // Only add light if light is on the same side as normal
                    float light_incident = max(0.0, dot(normal, dir_to_light));                         // Brightness depends on the angle between light and normal
                    vec3 diffuse = diffuse_color*light_incident;
                    
                    vec3 vect_reflection = -dir_to_light - 2.0 * dot(-dir_to_light, normal) * normal;	// Reflection vector pointing away from object
                    vec3 vect_camera = -ray_direction;													// Vector pointing from object to camera
                    float reflection_intensity = pow(max(0.0, dot(vect_reflection, vect_camera)), specular_exponent);// How closely the reflection vector points to the camera = intensity
                    vec3 specular = specular_color * reflection_intensity;
            
                    return incident_intensity * (diffuse + specular);
                }
            
                return vec3(0, 0, 0);
            }
            
            // Calculates and returns specular and diffuse illumination from all lights on a given point
            vec3 illumination(vec3 point, vec3 ray_dir, vec3 normal, vec3 diffuseColor, vec3 specularColor) {
                vec3 illuminationColor;
            
                for (int i = 0; i < MAX_LIGHTS; i++) {
                    if (i == numLights) break;
                    vec3 lightPos = lightPos[i];
                    vec3 lightIntensity = lightIntensity[i];
                    vec2 lightSize = lightSize[i];
                    vec2 lightSpot = lightSpot[i];
                    vec3 light_sum;
                    int areaShadowSamples = (lightSize.x > 0.0 && lightSize.y > 0.0) ? shadowSamples : 1;
            
                    for (int k = 0; k < MAX_SHADOW_SAMPLES; k++) {
                        if (k == areaShadowSamples) break;
                        vec3 incident_intensity, dir_to_light;
                        float light_distance;
                        getIncidentIntensity(float(k), point, lightPos, lightIntensity, lightSize, lightSpot, light_distance, dir_to_light, incident_intensity);
                        
                        if (length(incident_intensity) > 0.01) { // If there is no light at this point (distance or outside of spotlight) do not check for shadows
                            float t_shadowHit = light_distance;
                            intersectShadowRay(point, dir_to_light, t_shadowHit, 0.01);
                            if (abs(t_shadowHit - light_distance) < EPSILON) {
                                light_sum += shadePhong(ray_dir, normal, dir_to_light, incident_intensity, diffuseColor, specularColor);
                            }
                        }
                    }
            
                    illuminationColor += light_sum / float(areaShadowSamples);
                }
                return illuminationColor;
            }
            
            vec3 randomHemisphereDir(vec2 rand) {
                float z = random(rand) * 2.0 - 1.0;
                float a = random(rand) * PI2;       // uniform angle on [0, 2*pi]
                float r = sqrt(1.0 - z * z);        // uniform radius on hemisphere
                return vec3(r*cos(a), r*sin(a), z); // get cartesian coordinates
            }
            
            // Calculates and returns indirect illumination on a given point
            // uses only one bounce because of exponential performance hit
            vec3 indirectIllumination(vec3 point, vec3 rayDir, vec3 normal, vec3 diffuseColor, float roughness) {
                if (length(diffuseColor) == 0.0) return vec3(0,0,0); // don't do unneeded calculations if the surface doesn't have a diffuse color
            
                // Sample rays uniformly over hemisphere with spherical coordinates
                vec3 indirect_sampling_sum;
                for (int k = 0; k < MAX_GISAMPLES; k++) {
                    if (k >= indirectSamples) break;
            
                    vec3 diffuseDir = normalize(normal + randomHemisphereDir(point.xy));
                    vec3 mirrorDir = reflect(rayDir, normal);
                    vec3 indirectDir = normalize(mix(mirrorDir, diffuseDir, roughness));
            
                    float t_indirectHit = 10.0;
                    vec3 indirectHitPoint, indirectDiffuseColor, indirectSpecularColor, indirectRefColor, indirectNormal;
                    float indirectRoughness;
                    bool isLight = false;
            
                    // Intersect this bounced ray and get direct illumination from this point
                    intersect(point, indirectDir, t_indirectHit, 0.01, indirectHitPoint, indirectNormal, indirectDiffuseColor, indirectSpecularColor, indirectRefColor, indirectRoughness, isLight);
                    if (length(indirectRefColor) > 0.0) 
                        indirectDiffuseColor = indirectRefColor; // mirrors are treated as diffuse materials
                    indirect_sampling_sum += isLight ? indirectDiffuseColor : illumination(indirectHitPoint, indirectDir, indirectNormal, indirectDiffuseColor, indirectSpecularColor);
                }
                // Return the scaled indirect light
                return ((indirect_sampling_sum / float(indirectSamples)) * diffuseColor);
            }
            
            // Calculates and returns mirror reflections on a given point
            vec3 reflectionIllumination(vec3 origin, vec3 rayDir, vec3 normal, vec3 refColor) {
                vec3 reflectionSum, mirrorDir;
                for (int i = 0; i < MAX_RAYBOUNCES; i++) {
                    if (i >= rayBounces || length(refColor) == 0.0) break; // Stop if we reach max number of bounces or hit material that is not reflective
            
                    // Trace the mirror ray and add the result to pixel
                    mirrorDir = reflect(rayDir, normal); // Get the direction of the reflected ray
                    float t_bounceHit = 50.0;
                    bool isLight = false;
                    vec3 bounceDiffuseColor, bounceSpecularColor, bounceRefColor, bounceHitPoint;
                    float hitRoughness;
                    intersect(origin, mirrorDir, t_bounceHit, 0.01, bounceHitPoint, normal, bounceDiffuseColor, bounceSpecularColor, bounceRefColor, hitRoughness, isLight);
                    
                    vec3 mirror_sample_color = isLight ? bounceDiffuseColor : illumination(bounceHitPoint, mirrorDir, normal, bounceDiffuseColor, bounceSpecularColor);
                    
                    if (enableRefGI) // Add indirect illumination to reflection
                        mirror_sample_color += indirectIllumination(bounceHitPoint, mirrorDir, normal, bounceDiffuseColor, hitRoughness);
                    else
                        mirror_sample_color += ambientLight * bounceDiffuseColor;
            
                    reflectionSum += mirror_sample_color * refColor;
                    origin = bounceHitPoint;
                    rayDir = mirrorDir;
                    refColor = bounceRefColor * refColor;  // Successive ray colors are affected by each reflective surface's color
                }
                return reflectionSum;
            }
            
            vec3 LessThan(vec3 f, float value) {
                return vec3(
                    (f.x < value) ? 1.0 : 0.0,
                    (f.y < value) ? 1.0 : 0.0,
                    (f.z < value) ? 1.0 : 0.0);
            }
                      
            vec3 LinearToSRGB(vec3 rgb) {     
                return mix(
                    pow(rgb, vec3(1.0 / 2.2)) * 1.055 - 0.055,
                    rgb * 12.92,
                    LessThan(rgb, 0.0031308)
                );
            }
            
            vec3 ACESFilm(vec3 x) {
                x = ACESInputMat * x;
                vec3 a = x * (x + 0.0245786) - 0.000090537;
                vec3 b = x * (0.983729 * x + 0.4329510) + 0.238081;
                x = a / b;
                x = ACESOutputMat * x;
                return clamp(x, 0.0, 1.0);
            }
            
            
            void main() {
                vec3 ray_dir = normalize(ray);
                float t_hit = length(ray); // The far clipping distance
                vec3 pixelColor, diffuseColor, specularColor, reflectiveColor, normal, point;
                float roughness;
                bool isLight = false;
                randomIncrement = randomseed;
            
                // intersect the ray with objects (tmin is 0, because vertex shader places the origin in near clipping distance)
                intersect(origin, ray_dir, t_hit, 0.0, point, normal, diffuseColor, specularColor, reflectiveColor, roughness, isLight);
            
                if (isLight) {  // If the ray hit a light, return its color because it doesn't have any other properties than surface color
                    fragColor = vec4(diffuseColor, 1.0);
                    return;
                }
            
                // Ambient light
                if (!enableGI)
                    pixelColor += ambientLight * diffuseColor;
            
                // ==== DIRECT ILLUMINATION ====
                pixelColor += illumination(point, ray_dir, normal, diffuseColor, specularColor);
            
                // ==== INDIRECT ILLUMINATION ====
                if (enableGI)
                    pixelColor += indirectIllumination(point, ray_dir, normal, diffuseColor, roughness);
            
                // ==== MIRROR REFLECTION ====
                if (rayBounces > 0 && length(reflectiveColor) > 0.0)
                    pixelColor += reflectionIllumination(point, ray_dir, normal, reflectiveColor);
            
                // ACES tonemapping (source: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl)
                pixelColor = ACESFilm(pixelColor);
                pixelColor = LinearToSRGB(pixelColor);
                fragColor = vec4(pixelColor, 1);
            }
        </script>
        <script id="fragment-shader-fast" type="x-shader/x-vertex">#version 300 es
            precision mediump float;
            float randomIncrement;
            uniform float randomseed;
            uniform highp int numLights;
            uniform vec3 lightPos[2];
            uniform vec2 lightSize[2];
            uniform vec3 lightIntensity[2];
            uniform vec2 lightSpot[2];
            uniform highp int shadowSamples;
            uniform float shadowDim;
            uniform vec2 attenuation;
            uniform highp int numSpheres;
            uniform vec3 sphereCenters[5];
            uniform vec3 sphereColors[5];
            uniform vec3 reflectiveColors[5];
            uniform vec3 sphereSpecColors[5];
            uniform float sphereRoughness[5];
            uniform highp int numPlanes;
            uniform float planeOffsets[6];
            uniform vec3 planeNormals[6];
            uniform vec3 planeColors[6];
            uniform float planeRoughness[6];
            uniform highp int rayBounces;
            uniform vec3 ambientLight;
            uniform bool enableGI;
            uniform bool enableRefGI;
            uniform highp int indirectSamples;
            uniform bool enablePlaneBacksides;
            uniform bool enablePlaneMirrors;
            in lowp vec3 origin;
            in lowp vec3 ray;
            out lowp vec4 fragColor;
            void main ()
            {
              float roughness_1;
              vec3 reflectiveColor_2;
              vec3 specularColor_3;
              vec3 diffuseColor_4;
              lowp vec3 pixelColor_5;
              lowp vec3 tmpvar_6;
              tmpvar_6 = normalize(ray);
              randomIncrement = randomseed;
              lowp vec3 ray_origin_7;
              ray_origin_7 = origin;
              lowp vec3 ray_direction_8;
              ray_direction_8 = tmpvar_6;
              lowp float t_hit_9;
              t_hit_9 = sqrt(dot (ray, ray));
              lowp vec3 position_10;
              lowp vec3 normal_11;
              vec3 diffuseColor_12;
              diffuseColor_12 = diffuseColor_4;
              vec3 specularColor_13;
              specularColor_13 = specularColor_3;
              vec3 reflectiveColor_14;
              reflectiveColor_14 = reflectiveColor_2;
              float roughness_15;
              roughness_15 = roughness_1;
              bool isLight_16;
              isLight_16 = bool(0);
              highp int i_17;
              highp int i_18;
              highp int i_19;
              highp int idx_20;
              highp int intersected_21;
              intersected_21 = 0;
              idx_20 = 0;
              i_19 = 0;
              if ((0 < numSpheres)) {
                lowp float t_hit_22;
                t_hit_22 = t_hit_9;
                bool tmpvar_23;
                lowp vec3 tmpvar_24;
                tmpvar_24 = (sphereCenters[0] - origin);
                lowp float tmpvar_25;
                tmpvar_25 = dot (tmpvar_24, tmpvar_6);
                if ((tmpvar_25 < 0.0)) {
                  tmpvar_23 = bool(0);
                } else {
                  lowp float tmpvar_26;
                  tmpvar_26 = (dot (tmpvar_24, tmpvar_24) - (tmpvar_25 * tmpvar_25));
                  if ((tmpvar_26 > 0.64)) {
                    tmpvar_23 = bool(0);
                  } else {
                    lowp float tmpvar_27;
                    tmpvar_27 = sqrt((0.64 - tmpvar_26));
                    lowp float tmpvar_28;
                    tmpvar_28 = (tmpvar_25 - tmpvar_27);
                    lowp float tmpvar_29;
                    tmpvar_29 = (tmpvar_25 + tmpvar_27);
                    lowp float tmpvar_30;
                    if ((tmpvar_28 < 0.0)) {
                      tmpvar_30 = tmpvar_29;
                    } else {
                      tmpvar_30 = tmpvar_28;
                    };
                    if (((tmpvar_30 < t_hit_9) && (tmpvar_30 > 0.0))) {
                      t_hit_22 = tmpvar_30;
                      tmpvar_23 = bool(1);
                    } else {
                      tmpvar_23 = bool(0);
                    };
                  };
                };
                t_hit_9 = t_hit_22;
                if (tmpvar_23) {
                  idx_20 = i_19;
                  intersected_21 = 1;
                };
                i_19 = 1;
                if ((1 < numSpheres)) {
                  lowp float t_hit_31;
                  t_hit_31 = t_hit_22;
                  bool tmpvar_32;
                  lowp vec3 tmpvar_33;
                  tmpvar_33 = (sphereCenters[1] - origin);
                  lowp float tmpvar_34;
                  tmpvar_34 = dot (tmpvar_33, tmpvar_6);
                  if ((tmpvar_34 < 0.0)) {
                    tmpvar_32 = bool(0);
                  } else {
                    lowp float tmpvar_35;
                    tmpvar_35 = (dot (tmpvar_33, tmpvar_33) - (tmpvar_34 * tmpvar_34));
                    if ((tmpvar_35 > 0.64)) {
                      tmpvar_32 = bool(0);
                    } else {
                      lowp float tmpvar_36;
                      tmpvar_36 = sqrt((0.64 - tmpvar_35));
                      lowp float tmpvar_37;
                      tmpvar_37 = (tmpvar_34 - tmpvar_36);
                      lowp float tmpvar_38;
                      tmpvar_38 = (tmpvar_34 + tmpvar_36);
                      lowp float tmpvar_39;
                      if ((tmpvar_37 < 0.0)) {
                        tmpvar_39 = tmpvar_38;
                      } else {
                        tmpvar_39 = tmpvar_37;
                      };
                      if (((tmpvar_39 < t_hit_22) && (tmpvar_39 > 0.0))) {
                        t_hit_31 = tmpvar_39;
                        tmpvar_32 = bool(1);
                      } else {
                        tmpvar_32 = bool(0);
                      };
                    };
                  };
                  t_hit_9 = t_hit_31;
                  if (tmpvar_32) {
                    idx_20 = i_19;
                    intersected_21 = 1;
                  };
                  i_19 = 2;
                  if ((2 < numSpheres)) {
                    lowp float t_hit_40;
                    t_hit_40 = t_hit_31;
                    bool tmpvar_41;
                    lowp vec3 tmpvar_42;
                    tmpvar_42 = (sphereCenters[2] - origin);
                    lowp float tmpvar_43;
                    tmpvar_43 = dot (tmpvar_42, tmpvar_6);
                    if ((tmpvar_43 < 0.0)) {
                      tmpvar_41 = bool(0);
                    } else {
                      lowp float tmpvar_44;
                      tmpvar_44 = (dot (tmpvar_42, tmpvar_42) - (tmpvar_43 * tmpvar_43));
                      if ((tmpvar_44 > 0.64)) {
                        tmpvar_41 = bool(0);
                      } else {
                        lowp float tmpvar_45;
                        tmpvar_45 = sqrt((0.64 - tmpvar_44));
                        lowp float tmpvar_46;
                        tmpvar_46 = (tmpvar_43 - tmpvar_45);
                        lowp float tmpvar_47;
                        tmpvar_47 = (tmpvar_43 + tmpvar_45);
                        lowp float tmpvar_48;
                        if ((tmpvar_46 < 0.0)) {
                          tmpvar_48 = tmpvar_47;
                        } else {
                          tmpvar_48 = tmpvar_46;
                        };
                        if (((tmpvar_48 < t_hit_31) && (tmpvar_48 > 0.0))) {
                          t_hit_40 = tmpvar_48;
                          tmpvar_41 = bool(1);
                        } else {
                          tmpvar_41 = bool(0);
                        };
                      };
                    };
                    t_hit_9 = t_hit_40;
                    if (tmpvar_41) {
                      idx_20 = i_19;
                      intersected_21 = 1;
                    };
                    i_19 = 3;
                    if ((3 < numSpheres)) {
                      lowp float t_hit_49;
                      t_hit_49 = t_hit_40;
                      bool tmpvar_50;
                      lowp vec3 tmpvar_51;
                      tmpvar_51 = (sphereCenters[3] - origin);
                      lowp float tmpvar_52;
                      tmpvar_52 = dot (tmpvar_51, tmpvar_6);
                      if ((tmpvar_52 < 0.0)) {
                        tmpvar_50 = bool(0);
                      } else {
                        lowp float tmpvar_53;
                        tmpvar_53 = (dot (tmpvar_51, tmpvar_51) - (tmpvar_52 * tmpvar_52));
                        if ((tmpvar_53 > 0.64)) {
                          tmpvar_50 = bool(0);
                        } else {
                          lowp float tmpvar_54;
                          tmpvar_54 = sqrt((0.64 - tmpvar_53));
                          lowp float tmpvar_55;
                          tmpvar_55 = (tmpvar_52 - tmpvar_54);
                          lowp float tmpvar_56;
                          tmpvar_56 = (tmpvar_52 + tmpvar_54);
                          lowp float tmpvar_57;
                          if ((tmpvar_55 < 0.0)) {
                            tmpvar_57 = tmpvar_56;
                          } else {
                            tmpvar_57 = tmpvar_55;
                          };
                          if (((tmpvar_57 < t_hit_40) && (tmpvar_57 > 0.0))) {
                            t_hit_49 = tmpvar_57;
                            tmpvar_50 = bool(1);
                          } else {
                            tmpvar_50 = bool(0);
                          };
                        };
                      };
                      t_hit_9 = t_hit_49;
                      if (tmpvar_50) {
                        idx_20 = i_19;
                        intersected_21 = 1;
                      };
                      i_19 = 4;
                      if ((4 < numSpheres)) {
                        lowp float t_hit_58;
                        t_hit_58 = t_hit_49;
                        bool tmpvar_59;
                        lowp vec3 tmpvar_60;
                        tmpvar_60 = (sphereCenters[4] - origin);
                        lowp float tmpvar_61;
                        tmpvar_61 = dot (tmpvar_60, tmpvar_6);
                        if ((tmpvar_61 < 0.0)) {
                          tmpvar_59 = bool(0);
                        } else {
                          lowp float tmpvar_62;
                          tmpvar_62 = (dot (tmpvar_60, tmpvar_60) - (tmpvar_61 * tmpvar_61));
                          if ((tmpvar_62 > 0.64)) {
                            tmpvar_59 = bool(0);
                          } else {
                            lowp float tmpvar_63;
                            tmpvar_63 = sqrt((0.64 - tmpvar_62));
                            lowp float tmpvar_64;
                            tmpvar_64 = (tmpvar_61 - tmpvar_63);
                            lowp float tmpvar_65;
                            tmpvar_65 = (tmpvar_61 + tmpvar_63);
                            lowp float tmpvar_66;
                            if ((tmpvar_64 < 0.0)) {
                              tmpvar_66 = tmpvar_65;
                            } else {
                              tmpvar_66 = tmpvar_64;
                            };
                            if (((tmpvar_66 < t_hit_49) && (tmpvar_66 > 0.0))) {
                              t_hit_58 = tmpvar_66;
                              tmpvar_59 = bool(1);
                            } else {
                              tmpvar_59 = bool(0);
                            };
                          };
                        };
                        t_hit_9 = t_hit_58;
                        if (tmpvar_59) {
                          idx_20 = i_19;
                          intersected_21 = 1;
                        };
                        i_19 = 5;
                      };
                    };
                  };
                };
              };
              i_18 = 0;
              while (true) {
                bool tmp_67;
                if ((i_18 >= 6)) {
                  break;
                };
                if ((i_18 >= numPlanes)) {
                  break;
                };
                lowp vec3 tmpvar_68;
                tmpvar_68 = planeNormals[i_18];
                tmp_67 = bool(0);
                bool tmpvar_69;
                if (enablePlaneBacksides) {
                  tmpvar_69 = bool(1);
                } else {
                  tmpvar_69 = (dot (ray_direction_8, tmpvar_68) < 0.0);
                };
                if (tmpvar_69) {
                  lowp float t_hit_70;
                  t_hit_70 = t_hit_9;
                  bool tmpvar_71;
                  tmpvar_71 = bool(1);
                  bool tmpvar_72;
                  lowp vec3 tmpvar_73;
                  tmpvar_73 = (tmpvar_68 * planeOffsets[i_18]);
                  lowp float tmpvar_74;
                  tmpvar_74 = (((
                    (tmpvar_73.x + tmpvar_73.y)
                   + tmpvar_73.z) - dot (tmpvar_68, ray_origin_7)) / dot (tmpvar_68, ray_direction_8));
                  if (((tmpvar_74 < t_hit_9) && (tmpvar_74 > 0.0))) {
                    t_hit_70 = tmpvar_74;
                    tmpvar_72 = bool(1);
                    tmpvar_71 = bool(0);
                  };
                  if (tmpvar_71) {
                    tmpvar_72 = bool(0);
                    tmpvar_71 = bool(0);
                  };
                  t_hit_9 = t_hit_70;
                  tmp_67 = tmpvar_72;
                };
                if (tmp_67) {
                  normal_11 = tmpvar_68;
                  idx_20 = i_18;
                  intersected_21 = 2;
                };
                i_18++;
              };
              i_17 = 0;
              bool tmp_75;
              if ((0 < numLights)) {
                vec3 tmpvar_76;
                tmpvar_76 = lightPos[0];
                vec2 tmpvar_77;
                tmpvar_77 = lightSize[0];
                tmp_75 = bool(0);
                if (((tmpvar_77.x > 0.0) && (tmpvar_77.y > 0.0))) {
                  lowp float t_hit_78;
                  t_hit_78 = t_hit_9;
                  bool tmpvar_79;
                  tmpvar_79 = bool(1);
                  bool tmpvar_80;
                  vec3 tmpvar_81;
                  tmpvar_81 = (vec3(0.0, 1.0, 0.0) * tmpvar_76.y);
                  lowp float tmpvar_82;
                  tmpvar_82 = (((
                    (tmpvar_81.x + tmpvar_81.y)
                   + tmpvar_81.z) - origin.y) / tmpvar_6.y);
                  if (((tmpvar_82 < t_hit_9) && (tmpvar_82 > 0.0))) {
                    lowp vec3 tmpvar_83;
                    tmpvar_83 = (origin + (tmpvar_6 * tmpvar_82));
                    float tmpvar_84;
                    tmpvar_84 = sqrt(dot (tmpvar_77, tmpvar_77));
                    if (((tmpvar_84 == 0.0) || ((
                      ((tmpvar_83.x < (tmpvar_76.x + (tmpvar_77.x * 0.5))) && (tmpvar_83.x > (tmpvar_76.x - (tmpvar_77.x * 0.5))))
                     && 
                      (tmpvar_83.z < (tmpvar_76.z + (tmpvar_77.y * 0.5)))
                    ) && (tmpvar_83.z > 
                      (tmpvar_76.z - (tmpvar_77.y * 0.5))
                    )))) {
                      t_hit_78 = tmpvar_82;
                      tmpvar_80 = bool(1);
                      tmpvar_79 = bool(0);
                    };
                  };
                  if (tmpvar_79) {
                    tmpvar_80 = bool(0);
                    tmpvar_79 = bool(0);
                  };
                  t_hit_9 = t_hit_78;
                  tmp_75 = tmpvar_80;
                } else {
                  lowp float t_hit_85;
                  t_hit_85 = t_hit_9;
                  bool tmpvar_86;
                  lowp vec3 tmpvar_87;
                  tmpvar_87 = (tmpvar_76 - origin);
                  lowp float tmpvar_88;
                  tmpvar_88 = dot (tmpvar_87, tmpvar_6);
                  if ((tmpvar_88 < 0.0)) {
                    tmpvar_86 = bool(0);
                  } else {
                    lowp float tmpvar_89;
                    tmpvar_89 = (dot (tmpvar_87, tmpvar_87) - (tmpvar_88 * tmpvar_88));
                    if ((tmpvar_89 > 0.01)) {
                      tmpvar_86 = bool(0);
                    } else {
                      lowp float tmpvar_90;
                      tmpvar_90 = sqrt((0.01 - tmpvar_89));
                      lowp float tmpvar_91;
                      tmpvar_91 = (tmpvar_88 - tmpvar_90);
                      lowp float tmpvar_92;
                      tmpvar_92 = (tmpvar_88 + tmpvar_90);
                      lowp float tmpvar_93;
                      if ((tmpvar_91 < 0.0)) {
                        tmpvar_93 = tmpvar_92;
                      } else {
                        tmpvar_93 = tmpvar_91;
                      };
                      if (((tmpvar_93 < t_hit_9) && (tmpvar_93 > 0.0))) {
                        t_hit_85 = tmpvar_93;
                        tmpvar_86 = bool(1);
                      } else {
                        tmpvar_86 = bool(0);
                      };
                    };
                  };
                  t_hit_9 = t_hit_85;
                  tmp_75 = tmpvar_86;
                };
                if (tmp_75) {
                  idx_20 = i_17;
                  intersected_21 = 3;
                };
                i_17 = 1;
                bool tmp_94;
                if ((1 < numLights)) {
                  vec3 tmpvar_95;
                  tmpvar_95 = lightPos[1];
                  vec2 tmpvar_96;
                  tmpvar_96 = lightSize[1];
                  tmp_94 = bool(0);
                  if (((tmpvar_96.x > 0.0) && (tmpvar_96.y > 0.0))) {
                    lowp float t_hit_97;
                    t_hit_97 = t_hit_9;
                    bool tmpvar_98;
                    tmpvar_98 = bool(1);
                    bool tmpvar_99;
                    vec3 tmpvar_100;
                    tmpvar_100 = (vec3(0.0, 1.0, 0.0) * tmpvar_95.y);
                    lowp float tmpvar_101;
                    tmpvar_101 = (((
                      (tmpvar_100.x + tmpvar_100.y)
                     + tmpvar_100.z) - origin.y) / tmpvar_6.y);
                    if (((tmpvar_101 < t_hit_9) && (tmpvar_101 > 0.0))) {
                      lowp vec3 tmpvar_102;
                      tmpvar_102 = (origin + (tmpvar_6 * tmpvar_101));
                      float tmpvar_103;
                      tmpvar_103 = sqrt(dot (tmpvar_96, tmpvar_96));
                      if (((tmpvar_103 == 0.0) || ((
                        ((tmpvar_102.x < (tmpvar_95.x + (tmpvar_96.x * 0.5))) && (tmpvar_102.x > (tmpvar_95.x - (tmpvar_96.x * 0.5))))
                       && 
                        (tmpvar_102.z < (tmpvar_95.z + (tmpvar_96.y * 0.5)))
                      ) && (tmpvar_102.z > 
                        (tmpvar_95.z - (tmpvar_96.y * 0.5))
                      )))) {
                        t_hit_97 = tmpvar_101;
                        tmpvar_99 = bool(1);
                        tmpvar_98 = bool(0);
                      };
                    };
                    if (tmpvar_98) {
                      tmpvar_99 = bool(0);
                      tmpvar_98 = bool(0);
                    };
                    t_hit_9 = t_hit_97;
                    tmp_94 = tmpvar_99;
                  } else {
                    lowp float t_hit_104;
                    t_hit_104 = t_hit_9;
                    bool tmpvar_105;
                    lowp vec3 tmpvar_106;
                    tmpvar_106 = (tmpvar_95 - origin);
                    lowp float tmpvar_107;
                    tmpvar_107 = dot (tmpvar_106, tmpvar_6);
                    if ((tmpvar_107 < 0.0)) {
                      tmpvar_105 = bool(0);
                    } else {
                      lowp float tmpvar_108;
                      tmpvar_108 = (dot (tmpvar_106, tmpvar_106) - (tmpvar_107 * tmpvar_107));
                      if ((tmpvar_108 > 0.01)) {
                        tmpvar_105 = bool(0);
                      } else {
                        lowp float tmpvar_109;
                        tmpvar_109 = sqrt((0.01 - tmpvar_108));
                        lowp float tmpvar_110;
                        tmpvar_110 = (tmpvar_107 - tmpvar_109);
                        lowp float tmpvar_111;
                        tmpvar_111 = (tmpvar_107 + tmpvar_109);
                        lowp float tmpvar_112;
                        if ((tmpvar_110 < 0.0)) {
                          tmpvar_112 = tmpvar_111;
                        } else {
                          tmpvar_112 = tmpvar_110;
                        };
                        if (((tmpvar_112 < t_hit_9) && (tmpvar_112 > 0.0))) {
                          t_hit_104 = tmpvar_112;
                          tmpvar_105 = bool(1);
                        } else {
                          tmpvar_105 = bool(0);
                        };
                      };
                    };
                    t_hit_9 = t_hit_104;
                    tmp_94 = tmpvar_105;
                  };
                  if (tmp_94) {
                    idx_20 = i_17;
                    intersected_21 = 3;
                  };
                  i_17 = 2;
                };
              };
              position_10 = (origin + (tmpvar_6 * t_hit_9));
              if ((intersected_21 == 1)) {
                diffuseColor_12 = sphereColors[idx_20];
                specularColor_13 = sphereSpecColors[idx_20];
                reflectiveColor_14 = reflectiveColors[idx_20];
                roughness_15 = sphereRoughness[idx_20];
                lowp vec3 tmpvar_113;
                tmpvar_113 = normalize((position_10 - sphereCenters[idx_20]));
                normal_11 = tmpvar_113;
                lowp float tmpvar_114;
                tmpvar_114 = dot (tmpvar_113, -(tmpvar_6));
                if ((tmpvar_114 < 0.0)) {
                  normal_11 = -(tmpvar_113);
                };
              } else {
                if ((intersected_21 == 2)) {
                  if (enablePlaneMirrors) {
                    diffuseColor_12 = (planeColors[idx_20] * 0.01);
                    specularColor_13 = vec3(0.0, 0.0, 0.0);
                    reflectiveColor_14 = planeColors[idx_20];
                    roughness_15 = 1.0;
                  } else {
                    diffuseColor_12 = planeColors[idx_20];
                    specularColor_13 = vec3(0.0, 0.0, 0.0);
                    reflectiveColor_14 = vec3(0.0, 0.0, 0.0);
                    roughness_15 = planeRoughness[idx_20];
                  };
                  lowp float tmpvar_115;
                  tmpvar_115 = dot (normal_11, -(tmpvar_6));
                  if ((tmpvar_115 < 0.0)) {
                    normal_11 = -(normal_11);
                  };
                } else {
                  if ((intersected_21 == 3)) {
                    diffuseColor_12 = (lightIntensity[idx_20] / 25.0);
                    isLight_16 = bool(1);
                  };
                };
              };
              diffuseColor_4 = diffuseColor_12;
              specularColor_3 = specularColor_13;
              reflectiveColor_2 = reflectiveColor_14;
              roughness_1 = roughness_15;
              if (isLight_16) {
                lowp vec4 tmpvar_116;
                tmpvar_116.w = 1.0;
                tmpvar_116.xyz = diffuseColor_12;
                fragColor = tmpvar_116;
                return;
              };
              if (!(enableGI)) {
                pixelColor_5 = (pixelColor_5 + (ambientLight * diffuseColor_12));
              };
              lowp vec3 point_117;
              point_117 = position_10;
              lowp vec3 ray_dir_118;
              ray_dir_118 = tmpvar_6;
              lowp vec3 normal_119;
              normal_119 = normal_11;
              vec3 diffuseColor_120;
              diffuseColor_120 = diffuseColor_12;
              vec3 specularColor_121;
              specularColor_121 = specularColor_13;
              highp int i_122;
              lowp vec3 illuminationColor_123;
              i_122 = 0;
              while (true) {
                highp int k_124;
                bool inShade_125;
                highp int areaShadowSamples_126;
                bool isAreaLight_127;
                lowp vec3 light_sum_128;
                vec2 lightSpot_129;
                vec2 lightSize_130;
                vec3 lightIntensity_131;
                vec3 lightPos_132;
                if ((i_122 >= 2)) {
                  break;
                };
                if ((i_122 == numLights)) {
                  break;
                };
                lightPos_132 = lightPos[i_122];
                lightIntensity_131 = lightIntensity[i_122];
                vec2 tmpvar_133;
                tmpvar_133 = lightSize[i_122];
                lightSize_130 = tmpvar_133;
                lightSpot_129 = lightSpot[i_122];
                isAreaLight_127 = ((tmpvar_133.x > 0.0) && (tmpvar_133.y > 0.0));
                areaShadowSamples_126 = 0;
                inShade_125 = bool(0);
                k_124 = 0;
                while (true) {
                  vec3 testPos_134;
                  if ((k_124 >= 5)) {
                    break;
                  };
                  if (inShade_125) {
                    break;
                  };
                  if (((k_124 == 1) && !(isAreaLight_127))) {
                    break;
                  };
                  testPos_134 = lightPos_132;
                  if ((k_124 == 1)) {
                    testPos_134.x = (lightPos_132.x - (lightSize_130.x * 0.5));
                    testPos_134.z = (lightPos_132.z - (lightSize_130.y * 0.5));
                  } else {
                    if ((k_124 == 2)) {
                      testPos_134.x = (testPos_134.x + (lightSize_130.x * 0.5));
                      testPos_134.z = (testPos_134.z + (lightSize_130.y * 0.5));
                    } else {
                      if ((k_124 == 3)) {
                        testPos_134.x = (testPos_134.x + (lightSize_130.x * 0.5));
                        testPos_134.z = (testPos_134.z - (lightSize_130.y * 0.5));
                      } else {
                        if ((k_124 == 4)) {
                          testPos_134.x = (testPos_134.x - (lightSize_130.x * 0.5));
                          testPos_134.z = (testPos_134.z + (lightSize_130.y * 0.5));
                        };
                      };
                    };
                  };
                  lowp vec3 vec_to_light_135;
                  lowp vec3 incident_intensity_136;
                  lowp float spot_falloff_137;
                  vec_to_light_135 = (testPos_134 - point_117);
                  lowp float tmpvar_138;
                  tmpvar_138 = sqrt(dot (vec_to_light_135, vec_to_light_135));
                  lowp float tmpvar_139;
                  tmpvar_139 = (1.0/(((attenuation.x * 
                    (tmpvar_138 * tmpvar_138)
                  ) + (attenuation.y * tmpvar_138))));
                  lowp vec3 tmpvar_140;
                  tmpvar_140 = normalize(vec_to_light_135);
                  vec_to_light_135 = tmpvar_140;
                  spot_falloff_137 = 1.0;
                  if ((lightSpot_129.x > 0.0)) {
                    lowp float tmpvar_141;
                    if ((tmpvar_140.y > lightSpot_129.x)) {
                      tmpvar_141 = pow (tmpvar_140.y, lightSpot_129.y);
                    } else {
                      tmpvar_141 = 0.0;
                    };
                    spot_falloff_137 = tmpvar_141;
                  };
                  incident_intensity_136 = ((lightIntensity_131 * tmpvar_139) * spot_falloff_137);
                  lowp float tmpvar_142;
                  tmpvar_142 = sqrt(dot (incident_intensity_136, incident_intensity_136));
                  if ((tmpvar_142 > 0.01)) {
                    lowp vec3 ray_origin_143;
                    ray_origin_143 = point_117;
                    lowp vec3 ray_direction_144;
                    ray_direction_144 = tmpvar_140;
                    lowp float t_hit_145;
                    t_hit_145 = tmpvar_138;
                    bool tmpvar_146;
                    tmpvar_146 = bool(0);
                    highp int i_147;
                    highp int i_148;
                    i_148 = 0;
                    while (true) {
                      if ((i_148 >= 5)) {
                        break;
                      };
                      if ((i_148 == numSpheres)) {
                        break;
                      };
                      lowp float t_hit_149;
                      t_hit_149 = t_hit_145;
                      bool tmpvar_150;
                      lowp vec3 tmpvar_151;
                      tmpvar_151 = (sphereCenters[i_148] - ray_origin_143);
                      lowp float tmpvar_152;
                      tmpvar_152 = dot (tmpvar_151, ray_direction_144);
                      if ((tmpvar_152 < 0.0)) {
                        tmpvar_150 = bool(0);
                      } else {
                        lowp float tmpvar_153;
                        tmpvar_153 = (dot (tmpvar_151, tmpvar_151) - (tmpvar_152 * tmpvar_152));
                        if ((tmpvar_153 > 0.64)) {
                          tmpvar_150 = bool(0);
                        } else {
                          lowp float tmpvar_154;
                          tmpvar_154 = sqrt((0.64 - tmpvar_153));
                          lowp float tmpvar_155;
                          tmpvar_155 = (tmpvar_152 - tmpvar_154);
                          lowp float tmpvar_156;
                          tmpvar_156 = (tmpvar_152 + tmpvar_154);
                          lowp float tmpvar_157;
                          if ((tmpvar_155 < 0.01)) {
                            tmpvar_157 = tmpvar_156;
                          } else {
                            tmpvar_157 = tmpvar_155;
                          };
                          if (((tmpvar_157 < t_hit_145) && (tmpvar_157 > 0.01))) {
                            t_hit_149 = tmpvar_157;
                            tmpvar_150 = bool(1);
                          } else {
                            tmpvar_150 = bool(0);
                          };
                        };
                      };
                      t_hit_145 = t_hit_149;
                      if (tmpvar_150) {
                        tmpvar_146 = bool(1);
                        break;
                      };
                      i_148++;
                    };
                    if (!(tmpvar_146)) {
                      i_147 = 0;
                      while (true) {
                        if ((i_147 >= 6)) {
                          break;
                        };
                        if ((i_147 == numPlanes)) {
                          break;
                        };
                        vec3 normal_158;
                        normal_158 = planeNormals[i_147];
                        lowp float t_hit_159;
                        t_hit_159 = t_hit_145;
                        bool tmpvar_160;
                        tmpvar_160 = bool(1);
                        bool tmpvar_161;
                        vec3 tmpvar_162;
                        tmpvar_162 = (normal_158 * planeOffsets[i_147]);
                        lowp float tmpvar_163;
                        tmpvar_163 = (((
                          (tmpvar_162.x + tmpvar_162.y)
                         + tmpvar_162.z) - dot (normal_158, ray_origin_143)) / dot (normal_158, ray_direction_144));
                        if (((tmpvar_163 < t_hit_145) && (tmpvar_163 > 0.01))) {
                          t_hit_159 = tmpvar_163;
                          tmpvar_161 = bool(1);
                          tmpvar_160 = bool(0);
                        };
                        if (tmpvar_160) {
                          tmpvar_161 = bool(0);
                          tmpvar_160 = bool(0);
                        };
                        t_hit_145 = t_hit_159;
                        if (tmpvar_161) {
                          tmpvar_146 = bool(1);
                          break;
                        };
                        i_147++;
                      };
                      if (!(tmpvar_146)) {
                        tmpvar_146 = bool(1);
                      };
                    };
                    lowp float tmpvar_164;
                    tmpvar_164 = abs((t_hit_145 - tmpvar_138));
                    if ((tmpvar_164 < 0.001)) {
                      lowp vec3 tmpvar_165;
                      lowp float tmpvar_166;
                      tmpvar_166 = dot (normal_119, tmpvar_140);
                      if ((tmpvar_166 > 0.0)) {
                        tmpvar_165 = (incident_intensity_136 * ((diffuseColor_120 * 
                          max (0.0, dot (normal_119, tmpvar_140))
                        ) + (specularColor_121 * 
                          pow (max (0.0, dot ((
                            -(tmpvar_140)
                           - 
                            ((2.0 * dot (-(tmpvar_140), normal_119)) * normal_119)
                          ), -(ray_dir_118))), 32.0)
                        )));
                      } else {
                        tmpvar_165 = vec3(0.0, 0.0, 0.0);
                      };
                      light_sum_128 = (light_sum_128 + tmpvar_165);
                    } else {
                      inShade_125 = bool(1);
                    };
                  } else {
                    inShade_125 = bool(1);
                  };
                  areaShadowSamples_126++;
                  k_124++;
                };
                if ((isAreaLight_127 && inShade_125)) {
                  highp int k_167;
                  areaShadowSamples_126 = shadowSamples;
                  light_sum_128 = vec3(0.0, 0.0, 0.0);
                  k_167 = 0;
                  while (true) {
                    lowp vec3 incident_intensity_168;
                    if ((k_167 >= 25)) {
                      break;
                    };
                    if ((k_167 == areaShadowSamples_126)) {
                      break;
                    };
                    float sample_i_169;
                    sample_i_169 = float(k_167);
                    lowp vec3 vec_to_light_170;
                    lowp float spot_falloff_171;
                    float tmpvar_172;
                    tmpvar_172 = (1.0/(shadowDim));
                    randomIncrement += 0.02;
                    lowp float tmpvar_173;
                    tmpvar_173 = ((lightSize_130.x * tmpvar_172) * ((float(mod (sample_i_169, shadowDim))) + fract(
                      (cos(dot ((point_117.xy + randomIncrement), vec2(23.14069, 2.665144))) * 12345.68)
                    )));
                    randomIncrement += 0.02;
                    lowp vec3 tmpvar_174;
                    tmpvar_174.x = ((lightPos_132.x - (lightSize_130.x * 0.5)) + tmpvar_173);
                    tmpvar_174.y = lightPos_132.y;
                    tmpvar_174.z = ((lightPos_132.z - (lightSize_130.y * 0.5)) + ((lightSize_130.y * tmpvar_172) * (
                      floor((sample_i_169 * tmpvar_172))
                     + 
                      fract((cos(dot (
                        (point_117.yx + randomIncrement)
                      , vec2(23.14069, 2.665144))) * 12345.68))
                    )));
                    vec_to_light_170 = (tmpvar_174 - point_117);
                    lowp float tmpvar_175;
                    tmpvar_175 = sqrt(dot (vec_to_light_170, vec_to_light_170));
                    lowp float tmpvar_176;
                    tmpvar_176 = (1.0/(((attenuation.x * 
                      (tmpvar_175 * tmpvar_175)
                    ) + (attenuation.y * tmpvar_175))));
                    lowp vec3 tmpvar_177;
                    tmpvar_177 = normalize(vec_to_light_170);
                    vec_to_light_170 = tmpvar_177;
                    spot_falloff_171 = 1.0;
                    if ((lightSpot_129.x > 0.0)) {
                      lowp float tmpvar_178;
                      if ((tmpvar_177.y > lightSpot_129.x)) {
                        tmpvar_178 = pow (tmpvar_177.y, lightSpot_129.y);
                      } else {
                        tmpvar_178 = 0.0;
                      };
                      spot_falloff_171 = tmpvar_178;
                    };
                    incident_intensity_168 = ((lightIntensity_131 * tmpvar_176) * spot_falloff_171);
                    lowp vec3 ray_origin_179;
                    ray_origin_179 = point_117;
                    lowp vec3 ray_direction_180;
                    ray_direction_180 = tmpvar_177;
                    lowp float t_hit_181;
                    t_hit_181 = tmpvar_175;
                    bool tmpvar_182;
                    tmpvar_182 = bool(0);
                    highp int i_183;
                    highp int i_184;
                    i_184 = 0;
                    while (true) {
                      if ((i_184 >= 5)) {
                        break;
                      };
                      if ((i_184 == numSpheres)) {
                        break;
                      };
                      lowp float t_hit_185;
                      t_hit_185 = t_hit_181;
                      bool tmpvar_186;
                      lowp vec3 tmpvar_187;
                      tmpvar_187 = (sphereCenters[i_184] - ray_origin_179);
                      lowp float tmpvar_188;
                      tmpvar_188 = dot (tmpvar_187, ray_direction_180);
                      if ((tmpvar_188 < 0.0)) {
                        tmpvar_186 = bool(0);
                      } else {
                        lowp float tmpvar_189;
                        tmpvar_189 = (dot (tmpvar_187, tmpvar_187) - (tmpvar_188 * tmpvar_188));
                        if ((tmpvar_189 > 0.64)) {
                          tmpvar_186 = bool(0);
                        } else {
                          lowp float tmpvar_190;
                          tmpvar_190 = sqrt((0.64 - tmpvar_189));
                          lowp float tmpvar_191;
                          tmpvar_191 = (tmpvar_188 - tmpvar_190);
                          lowp float tmpvar_192;
                          tmpvar_192 = (tmpvar_188 + tmpvar_190);
                          lowp float tmpvar_193;
                          if ((tmpvar_191 < 0.01)) {
                            tmpvar_193 = tmpvar_192;
                          } else {
                            tmpvar_193 = tmpvar_191;
                          };
                          if (((tmpvar_193 < t_hit_181) && (tmpvar_193 > 0.01))) {
                            t_hit_185 = tmpvar_193;
                            tmpvar_186 = bool(1);
                          } else {
                            tmpvar_186 = bool(0);
                          };
                        };
                      };
                      t_hit_181 = t_hit_185;
                      if (tmpvar_186) {
                        tmpvar_182 = bool(1);
                        break;
                      };
                      i_184++;
                    };
                    if (!(tmpvar_182)) {
                      i_183 = 0;
                      while (true) {
                        if ((i_183 >= 6)) {
                          break;
                        };
                        if ((i_183 == numPlanes)) {
                          break;
                        };
                        vec3 normal_194;
                        normal_194 = planeNormals[i_183];
                        lowp float t_hit_195;
                        t_hit_195 = t_hit_181;
                        bool tmpvar_196;
                        tmpvar_196 = bool(1);
                        bool tmpvar_197;
                        vec3 tmpvar_198;
                        tmpvar_198 = (normal_194 * planeOffsets[i_183]);
                        lowp float tmpvar_199;
                        tmpvar_199 = (((
                          (tmpvar_198.x + tmpvar_198.y)
                         + tmpvar_198.z) - dot (normal_194, ray_origin_179)) / dot (normal_194, ray_direction_180));
                        if (((tmpvar_199 < t_hit_181) && (tmpvar_199 > 0.01))) {
                          t_hit_195 = tmpvar_199;
                          tmpvar_197 = bool(1);
                          tmpvar_196 = bool(0);
                        };
                        if (tmpvar_196) {
                          tmpvar_197 = bool(0);
                          tmpvar_196 = bool(0);
                        };
                        t_hit_181 = t_hit_195;
                        if (tmpvar_197) {
                          tmpvar_182 = bool(1);
                          break;
                        };
                        i_183++;
                      };
                      if (!(tmpvar_182)) {
                        tmpvar_182 = bool(1);
                      };
                    };
                    lowp float tmpvar_200;
                    tmpvar_200 = abs((t_hit_181 - tmpvar_175));
                    if ((tmpvar_200 < 0.001)) {
                      lowp vec3 tmpvar_201;
                      lowp float tmpvar_202;
                      tmpvar_202 = dot (normal_119, tmpvar_177);
                      if ((tmpvar_202 > 0.0)) {
                        tmpvar_201 = (incident_intensity_168 * ((diffuseColor_120 * 
                          max (0.0, dot (normal_119, tmpvar_177))
                        ) + (specularColor_121 * 
                          pow (max (0.0, dot ((
                            -(tmpvar_177)
                           - 
                            ((2.0 * dot (-(tmpvar_177), normal_119)) * normal_119)
                          ), -(ray_dir_118))), 32.0)
                        )));
                      } else {
                        tmpvar_201 = vec3(0.0, 0.0, 0.0);
                      };
                      light_sum_128 = (light_sum_128 + tmpvar_201);
                    };
                    k_167++;
                  };
                };
                illuminationColor_123 = (illuminationColor_123 + (light_sum_128 / float(areaShadowSamples_126)));
                i_122++;
              };
              pixelColor_5 = (pixelColor_5 + illuminationColor_123);
              if (enableGI) {
                lowp vec3 point_203;
                point_203 = position_10;
                lowp vec3 rayDir_204;
                rayDir_204 = tmpvar_6;
                lowp vec3 normal_205;
                normal_205 = normal_11;
                float roughness_206;
                roughness_206 = roughness_15;
                lowp vec3 tmpvar_207;
                highp int k_208;
                lowp vec3 indirect_sampling_sum_209;
                float tmpvar_210;
                tmpvar_210 = sqrt(dot (diffuseColor_12, diffuseColor_12));
                if ((tmpvar_210 == 0.0)) {
                  tmpvar_207 = vec3(0.0, 0.0, 0.0);
                } else {
                  k_208 = 0;
                  while (true) {
                    float indirectRoughness_211;
                    vec3 indirectRefColor_212;
                    vec3 indirectSpecularColor_213;
                    vec3 indirectDiffuseColor_214;
                    if ((k_208 >= 100)) {
                      break;
                    };
                    if ((k_208 >= indirectSamples)) {
                      break;
                    };
                    randomIncrement += 0.02;
                    lowp float tmpvar_215;
                    tmpvar_215 = ((fract(
                      (cos(dot ((point_203.xy + randomIncrement), vec2(23.14069, 2.665144))) * 12345.68)
                    ) * 2.0) - 1.0);
                    randomIncrement += 0.02;
                    lowp float tmpvar_216;
                    tmpvar_216 = (fract((
                      cos(dot ((point_203.xy + randomIncrement), vec2(23.14069, 2.665144)))
                     * 12345.68)) * 6.283185);
                    lowp float tmpvar_217;
                    tmpvar_217 = sqrt((1.0 - (tmpvar_215 * tmpvar_215)));
                    lowp vec3 tmpvar_218;
                    tmpvar_218.x = (tmpvar_217 * cos(tmpvar_216));
                    tmpvar_218.y = (tmpvar_217 * sin(tmpvar_216));
                    tmpvar_218.z = tmpvar_215;
                    lowp vec3 tmpvar_219;
                    tmpvar_219 = normalize(mix ((rayDir_204 - 
                      (2.0 * (dot (normal_205, rayDir_204) * normal_205))
                    ), normalize(
                      (normal_205 + tmpvar_218)
                    ), roughness_206));
                    lowp vec3 ray_origin_220;
                    ray_origin_220 = point_203;
                    lowp vec3 ray_direction_221;
                    ray_direction_221 = tmpvar_219;
                    lowp float t_hit_222;
                    t_hit_222 = 10.0;
                    lowp vec3 position_223;
                    lowp vec3 normal_224;
                    vec3 diffuseColor_225;
                    diffuseColor_225 = indirectDiffuseColor_214;
                    vec3 specularColor_226;
                    specularColor_226 = indirectSpecularColor_213;
                    vec3 reflectiveColor_227;
                    reflectiveColor_227 = indirectRefColor_212;
                    float roughness_228;
                    roughness_228 = indirectRoughness_211;
                    bool isLight_229;
                    isLight_229 = bool(0);
                    highp int i_230;
                    highp int i_231;
                    highp int i_232;
                    highp int idx_233;
                    highp int intersected_234;
                    intersected_234 = 0;
                    idx_233 = 0;
                    i_232 = 0;
                    if ((0 < numSpheres)) {
                      lowp float t_hit_235;
                      t_hit_235 = t_hit_222;
                      bool tmpvar_236;
                      lowp vec3 tmpvar_237;
                      tmpvar_237 = (sphereCenters[0] - point_203);
                      lowp float tmpvar_238;
                      tmpvar_238 = dot (tmpvar_237, tmpvar_219);
                      if ((tmpvar_238 < 0.0)) {
                        tmpvar_236 = bool(0);
                      } else {
                        lowp float tmpvar_239;
                        tmpvar_239 = (dot (tmpvar_237, tmpvar_237) - (tmpvar_238 * tmpvar_238));
                        if ((tmpvar_239 > 0.64)) {
                          tmpvar_236 = bool(0);
                        } else {
                          lowp float tmpvar_240;
                          tmpvar_240 = sqrt((0.64 - tmpvar_239));
                          lowp float tmpvar_241;
                          tmpvar_241 = (tmpvar_238 - tmpvar_240);
                          lowp float tmpvar_242;
                          tmpvar_242 = (tmpvar_238 + tmpvar_240);
                          lowp float tmpvar_243;
                          if ((tmpvar_241 < 0.01)) {
                            tmpvar_243 = tmpvar_242;
                          } else {
                            tmpvar_243 = tmpvar_241;
                          };
                          if (((tmpvar_243 < 10.0) && (tmpvar_243 > 0.01))) {
                            t_hit_235 = tmpvar_243;
                            tmpvar_236 = bool(1);
                          } else {
                            tmpvar_236 = bool(0);
                          };
                        };
                      };
                      t_hit_222 = t_hit_235;
                      if (tmpvar_236) {
                        idx_233 = i_232;
                        intersected_234 = 1;
                      };
                      i_232 = 1;
                      if ((1 < numSpheres)) {
                        lowp float t_hit_244;
                        t_hit_244 = t_hit_235;
                        bool tmpvar_245;
                        lowp vec3 tmpvar_246;
                        tmpvar_246 = (sphereCenters[1] - point_203);
                        lowp float tmpvar_247;
                        tmpvar_247 = dot (tmpvar_246, tmpvar_219);
                        if ((tmpvar_247 < 0.0)) {
                          tmpvar_245 = bool(0);
                        } else {
                          lowp float tmpvar_248;
                          tmpvar_248 = (dot (tmpvar_246, tmpvar_246) - (tmpvar_247 * tmpvar_247));
                          if ((tmpvar_248 > 0.64)) {
                            tmpvar_245 = bool(0);
                          } else {
                            lowp float tmpvar_249;
                            tmpvar_249 = sqrt((0.64 - tmpvar_248));
                            lowp float tmpvar_250;
                            tmpvar_250 = (tmpvar_247 - tmpvar_249);
                            lowp float tmpvar_251;
                            tmpvar_251 = (tmpvar_247 + tmpvar_249);
                            lowp float tmpvar_252;
                            if ((tmpvar_250 < 0.01)) {
                              tmpvar_252 = tmpvar_251;
                            } else {
                              tmpvar_252 = tmpvar_250;
                            };
                            if (((tmpvar_252 < t_hit_235) && (tmpvar_252 > 0.01))) {
                              t_hit_244 = tmpvar_252;
                              tmpvar_245 = bool(1);
                            } else {
                              tmpvar_245 = bool(0);
                            };
                          };
                        };
                        t_hit_222 = t_hit_244;
                        if (tmpvar_245) {
                          idx_233 = i_232;
                          intersected_234 = 1;
                        };
                        i_232 = 2;
                        if ((2 < numSpheres)) {
                          lowp float t_hit_253;
                          t_hit_253 = t_hit_244;
                          bool tmpvar_254;
                          lowp vec3 tmpvar_255;
                          tmpvar_255 = (sphereCenters[2] - point_203);
                          lowp float tmpvar_256;
                          tmpvar_256 = dot (tmpvar_255, tmpvar_219);
                          if ((tmpvar_256 < 0.0)) {
                            tmpvar_254 = bool(0);
                          } else {
                            lowp float tmpvar_257;
                            tmpvar_257 = (dot (tmpvar_255, tmpvar_255) - (tmpvar_256 * tmpvar_256));
                            if ((tmpvar_257 > 0.64)) {
                              tmpvar_254 = bool(0);
                            } else {
                              lowp float tmpvar_258;
                              tmpvar_258 = sqrt((0.64 - tmpvar_257));
                              lowp float tmpvar_259;
                              tmpvar_259 = (tmpvar_256 - tmpvar_258);
                              lowp float tmpvar_260;
                              tmpvar_260 = (tmpvar_256 + tmpvar_258);
                              lowp float tmpvar_261;
                              if ((tmpvar_259 < 0.01)) {
                                tmpvar_261 = tmpvar_260;
                              } else {
                                tmpvar_261 = tmpvar_259;
                              };
                              if (((tmpvar_261 < t_hit_244) && (tmpvar_261 > 0.01))) {
                                t_hit_253 = tmpvar_261;
                                tmpvar_254 = bool(1);
                              } else {
                                tmpvar_254 = bool(0);
                              };
                            };
                          };
                          t_hit_222 = t_hit_253;
                          if (tmpvar_254) {
                            idx_233 = i_232;
                            intersected_234 = 1;
                          };
                          i_232 = 3;
                          if ((3 < numSpheres)) {
                            lowp float t_hit_262;
                            t_hit_262 = t_hit_253;
                            bool tmpvar_263;
                            lowp vec3 tmpvar_264;
                            tmpvar_264 = (sphereCenters[3] - point_203);
                            lowp float tmpvar_265;
                            tmpvar_265 = dot (tmpvar_264, tmpvar_219);
                            if ((tmpvar_265 < 0.0)) {
                              tmpvar_263 = bool(0);
                            } else {
                              lowp float tmpvar_266;
                              tmpvar_266 = (dot (tmpvar_264, tmpvar_264) - (tmpvar_265 * tmpvar_265));
                              if ((tmpvar_266 > 0.64)) {
                                tmpvar_263 = bool(0);
                              } else {
                                lowp float tmpvar_267;
                                tmpvar_267 = sqrt((0.64 - tmpvar_266));
                                lowp float tmpvar_268;
                                tmpvar_268 = (tmpvar_265 - tmpvar_267);
                                lowp float tmpvar_269;
                                tmpvar_269 = (tmpvar_265 + tmpvar_267);
                                lowp float tmpvar_270;
                                if ((tmpvar_268 < 0.01)) {
                                  tmpvar_270 = tmpvar_269;
                                } else {
                                  tmpvar_270 = tmpvar_268;
                                };
                                if (((tmpvar_270 < t_hit_253) && (tmpvar_270 > 0.01))) {
                                  t_hit_262 = tmpvar_270;
                                  tmpvar_263 = bool(1);
                                } else {
                                  tmpvar_263 = bool(0);
                                };
                              };
                            };
                            t_hit_222 = t_hit_262;
                            if (tmpvar_263) {
                              idx_233 = i_232;
                              intersected_234 = 1;
                            };
                            i_232 = 4;
                            if ((4 < numSpheres)) {
                              lowp float t_hit_271;
                              t_hit_271 = t_hit_262;
                              bool tmpvar_272;
                              lowp vec3 tmpvar_273;
                              tmpvar_273 = (sphereCenters[4] - point_203);
                              lowp float tmpvar_274;
                              tmpvar_274 = dot (tmpvar_273, tmpvar_219);
                              if ((tmpvar_274 < 0.0)) {
                                tmpvar_272 = bool(0);
                              } else {
                                lowp float tmpvar_275;
                                tmpvar_275 = (dot (tmpvar_273, tmpvar_273) - (tmpvar_274 * tmpvar_274));
                                if ((tmpvar_275 > 0.64)) {
                                  tmpvar_272 = bool(0);
                                } else {
                                  lowp float tmpvar_276;
                                  tmpvar_276 = sqrt((0.64 - tmpvar_275));
                                  lowp float tmpvar_277;
                                  tmpvar_277 = (tmpvar_274 - tmpvar_276);
                                  lowp float tmpvar_278;
                                  tmpvar_278 = (tmpvar_274 + tmpvar_276);
                                  lowp float tmpvar_279;
                                  if ((tmpvar_277 < 0.01)) {
                                    tmpvar_279 = tmpvar_278;
                                  } else {
                                    tmpvar_279 = tmpvar_277;
                                  };
                                  if (((tmpvar_279 < t_hit_262) && (tmpvar_279 > 0.01))) {
                                    t_hit_271 = tmpvar_279;
                                    tmpvar_272 = bool(1);
                                  } else {
                                    tmpvar_272 = bool(0);
                                  };
                                };
                              };
                              t_hit_222 = t_hit_271;
                              if (tmpvar_272) {
                                idx_233 = i_232;
                                intersected_234 = 1;
                              };
                              i_232 = 5;
                            };
                          };
                        };
                      };
                    };
                    i_231 = 0;
                    while (true) {
                      bool tmp_280;
                      if ((i_231 >= 6)) {
                        break;
                      };
                      if ((i_231 >= numPlanes)) {
                        break;
                      };
                      lowp vec3 tmpvar_281;
                      tmpvar_281 = planeNormals[i_231];
                      tmp_280 = bool(0);
                      bool tmpvar_282;
                      if (enablePlaneBacksides) {
                        tmpvar_282 = bool(1);
                      } else {
                        tmpvar_282 = (dot (ray_direction_221, tmpvar_281) < 0.0);
                      };
                      if (tmpvar_282) {
                        lowp float t_hit_283;
                        t_hit_283 = t_hit_222;
                        bool tmpvar_284;
                        tmpvar_284 = bool(1);
                        bool tmpvar_285;
                        lowp vec3 tmpvar_286;
                        tmpvar_286 = (tmpvar_281 * planeOffsets[i_231]);
                        lowp float tmpvar_287;
                        tmpvar_287 = (((
                          (tmpvar_286.x + tmpvar_286.y)
                         + tmpvar_286.z) - dot (tmpvar_281, ray_origin_220)) / dot (tmpvar_281, ray_direction_221));
                        if (((tmpvar_287 < t_hit_222) && (tmpvar_287 > 0.01))) {
                          t_hit_283 = tmpvar_287;
                          tmpvar_285 = bool(1);
                          tmpvar_284 = bool(0);
                        };
                        if (tmpvar_284) {
                          tmpvar_285 = bool(0);
                          tmpvar_284 = bool(0);
                        };
                        t_hit_222 = t_hit_283;
                        tmp_280 = tmpvar_285;
                      };
                      if (tmp_280) {
                        normal_224 = tmpvar_281;
                        idx_233 = i_231;
                        intersected_234 = 2;
                      };
                      i_231++;
                    };
                    i_230 = 0;
                    bool tmp_288;
                    if ((0 < numLights)) {
                      vec3 tmpvar_289;
                      tmpvar_289 = lightPos[0];
                      vec2 tmpvar_290;
                      tmpvar_290 = lightSize[0];
                      tmp_288 = bool(0);
                      if (((tmpvar_290.x > 0.0) && (tmpvar_290.y > 0.0))) {
                        lowp float t_hit_291;
                        t_hit_291 = t_hit_222;
                        bool tmpvar_292;
                        tmpvar_292 = bool(1);
                        bool tmpvar_293;
                        vec3 tmpvar_294;
                        tmpvar_294 = (vec3(0.0, 1.0, 0.0) * tmpvar_289.y);
                        lowp float tmpvar_295;
                        tmpvar_295 = (((
                          (tmpvar_294.x + tmpvar_294.y)
                         + tmpvar_294.z) - point_203.y) / tmpvar_219.y);
                        if (((tmpvar_295 < t_hit_222) && (tmpvar_295 > 0.01))) {
                          lowp vec3 tmpvar_296;
                          tmpvar_296 = (point_203 + (tmpvar_219 * tmpvar_295));
                          float tmpvar_297;
                          tmpvar_297 = sqrt(dot (tmpvar_290, tmpvar_290));
                          if (((tmpvar_297 == 0.0) || ((
                            ((tmpvar_296.x < (tmpvar_289.x + (tmpvar_290.x * 0.5))) && (tmpvar_296.x > (tmpvar_289.x - (tmpvar_290.x * 0.5))))
                           && 
                            (tmpvar_296.z < (tmpvar_289.z + (tmpvar_290.y * 0.5)))
                          ) && (tmpvar_296.z > 
                            (tmpvar_289.z - (tmpvar_290.y * 0.5))
                          )))) {
                            t_hit_291 = tmpvar_295;
                            tmpvar_293 = bool(1);
                            tmpvar_292 = bool(0);
                          };
                        };
                        if (tmpvar_292) {
                          tmpvar_293 = bool(0);
                          tmpvar_292 = bool(0);
                        };
                        t_hit_222 = t_hit_291;
                        tmp_288 = tmpvar_293;
                      } else {
                        lowp float t_hit_298;
                        t_hit_298 = t_hit_222;
                        bool tmpvar_299;
                        lowp vec3 tmpvar_300;
                        tmpvar_300 = (tmpvar_289 - point_203);
                        lowp float tmpvar_301;
                        tmpvar_301 = dot (tmpvar_300, tmpvar_219);
                        if ((tmpvar_301 < 0.0)) {
                          tmpvar_299 = bool(0);
                        } else {
                          lowp float tmpvar_302;
                          tmpvar_302 = (dot (tmpvar_300, tmpvar_300) - (tmpvar_301 * tmpvar_301));
                          if ((tmpvar_302 > 0.01)) {
                            tmpvar_299 = bool(0);
                          } else {
                            lowp float tmpvar_303;
                            tmpvar_303 = sqrt((0.01 - tmpvar_302));
                            lowp float tmpvar_304;
                            tmpvar_304 = (tmpvar_301 - tmpvar_303);
                            lowp float tmpvar_305;
                            tmpvar_305 = (tmpvar_301 + tmpvar_303);
                            lowp float tmpvar_306;
                            if ((tmpvar_304 < 0.01)) {
                              tmpvar_306 = tmpvar_305;
                            } else {
                              tmpvar_306 = tmpvar_304;
                            };
                            if (((tmpvar_306 < t_hit_222) && (tmpvar_306 > 0.01))) {
                              t_hit_298 = tmpvar_306;
                              tmpvar_299 = bool(1);
                            } else {
                              tmpvar_299 = bool(0);
                            };
                          };
                        };
                        t_hit_222 = t_hit_298;
                        tmp_288 = tmpvar_299;
                      };
                      if (tmp_288) {
                        idx_233 = i_230;
                        intersected_234 = 3;
                      };
                      i_230 = 1;
                      bool tmp_307;
                      if ((1 < numLights)) {
                        vec3 tmpvar_308;
                        tmpvar_308 = lightPos[1];
                        vec2 tmpvar_309;
                        tmpvar_309 = lightSize[1];
                        tmp_307 = bool(0);
                        if (((tmpvar_309.x > 0.0) && (tmpvar_309.y > 0.0))) {
                          lowp float t_hit_310;
                          t_hit_310 = t_hit_222;
                          bool tmpvar_311;
                          tmpvar_311 = bool(1);
                          bool tmpvar_312;
                          vec3 tmpvar_313;
                          tmpvar_313 = (vec3(0.0, 1.0, 0.0) * tmpvar_308.y);
                          lowp float tmpvar_314;
                          tmpvar_314 = (((
                            (tmpvar_313.x + tmpvar_313.y)
                           + tmpvar_313.z) - point_203.y) / tmpvar_219.y);
                          if (((tmpvar_314 < t_hit_222) && (tmpvar_314 > 0.01))) {
                            lowp vec3 tmpvar_315;
                            tmpvar_315 = (point_203 + (tmpvar_219 * tmpvar_314));
                            float tmpvar_316;
                            tmpvar_316 = sqrt(dot (tmpvar_309, tmpvar_309));
                            if (((tmpvar_316 == 0.0) || ((
                              ((tmpvar_315.x < (tmpvar_308.x + (tmpvar_309.x * 0.5))) && (tmpvar_315.x > (tmpvar_308.x - (tmpvar_309.x * 0.5))))
                             && 
                              (tmpvar_315.z < (tmpvar_308.z + (tmpvar_309.y * 0.5)))
                            ) && (tmpvar_315.z > 
                              (tmpvar_308.z - (tmpvar_309.y * 0.5))
                            )))) {
                              t_hit_310 = tmpvar_314;
                              tmpvar_312 = bool(1);
                              tmpvar_311 = bool(0);
                            };
                          };
                          if (tmpvar_311) {
                            tmpvar_312 = bool(0);
                            tmpvar_311 = bool(0);
                          };
                          t_hit_222 = t_hit_310;
                          tmp_307 = tmpvar_312;
                        } else {
                          lowp float t_hit_317;
                          t_hit_317 = t_hit_222;
                          bool tmpvar_318;
                          lowp vec3 tmpvar_319;
                          tmpvar_319 = (tmpvar_308 - point_203);
                          lowp float tmpvar_320;
                          tmpvar_320 = dot (tmpvar_319, tmpvar_219);
                          if ((tmpvar_320 < 0.0)) {
                            tmpvar_318 = bool(0);
                          } else {
                            lowp float tmpvar_321;
                            tmpvar_321 = (dot (tmpvar_319, tmpvar_319) - (tmpvar_320 * tmpvar_320));
                            if ((tmpvar_321 > 0.01)) {
                              tmpvar_318 = bool(0);
                            } else {
                              lowp float tmpvar_322;
                              tmpvar_322 = sqrt((0.01 - tmpvar_321));
                              lowp float tmpvar_323;
                              tmpvar_323 = (tmpvar_320 - tmpvar_322);
                              lowp float tmpvar_324;
                              tmpvar_324 = (tmpvar_320 + tmpvar_322);
                              lowp float tmpvar_325;
                              if ((tmpvar_323 < 0.01)) {
                                tmpvar_325 = tmpvar_324;
                              } else {
                                tmpvar_325 = tmpvar_323;
                              };
                              if (((tmpvar_325 < t_hit_222) && (tmpvar_325 > 0.01))) {
                                t_hit_317 = tmpvar_325;
                                tmpvar_318 = bool(1);
                              } else {
                                tmpvar_318 = bool(0);
                              };
                            };
                          };
                          t_hit_222 = t_hit_317;
                          tmp_307 = tmpvar_318;
                        };
                        if (tmp_307) {
                          idx_233 = i_230;
                          intersected_234 = 3;
                        };
                        i_230 = 2;
                      };
                    };
                    position_223 = (point_203 + (tmpvar_219 * t_hit_222));
                    if ((intersected_234 == 1)) {
                      diffuseColor_225 = sphereColors[idx_233];
                      specularColor_226 = sphereSpecColors[idx_233];
                      reflectiveColor_227 = reflectiveColors[idx_233];
                      roughness_228 = sphereRoughness[idx_233];
                      lowp vec3 tmpvar_326;
                      tmpvar_326 = normalize((position_223 - sphereCenters[idx_233]));
                      normal_224 = tmpvar_326;
                      lowp float tmpvar_327;
                      tmpvar_327 = dot (tmpvar_326, -(tmpvar_219));
                      if ((tmpvar_327 < 0.0)) {
                        normal_224 = -(tmpvar_326);
                      };
                    } else {
                      if ((intersected_234 == 2)) {
                        if (enablePlaneMirrors) {
                          diffuseColor_225 = (planeColors[idx_233] * 0.01);
                          specularColor_226 = vec3(0.0, 0.0, 0.0);
                          reflectiveColor_227 = planeColors[idx_233];
                          roughness_228 = 1.0;
                        } else {
                          diffuseColor_225 = planeColors[idx_233];
                          specularColor_226 = vec3(0.0, 0.0, 0.0);
                          reflectiveColor_227 = vec3(0.0, 0.0, 0.0);
                          roughness_228 = planeRoughness[idx_233];
                        };
                        lowp float tmpvar_328;
                        tmpvar_328 = dot (normal_224, -(tmpvar_219));
                        if ((tmpvar_328 < 0.0)) {
                          normal_224 = -(normal_224);
                        };
                      } else {
                        if ((intersected_234 == 3)) {
                          diffuseColor_225 = (lightIntensity[idx_233] / 25.0);
                          isLight_229 = bool(1);
                        };
                      };
                    };
                    indirectDiffuseColor_214 = diffuseColor_225;
                    indirectSpecularColor_213 = specularColor_226;
                    indirectRefColor_212 = reflectiveColor_227;
                    indirectRoughness_211 = roughness_228;
                    float tmpvar_329;
                    tmpvar_329 = sqrt(dot (reflectiveColor_227, reflectiveColor_227));
                    if ((tmpvar_329 > 0.0)) {
                      indirectDiffuseColor_214 = reflectiveColor_227;
                    };
                    lowp vec3 tmpvar_330;
                    if (isLight_229) {
                      tmpvar_330 = indirectDiffuseColor_214;
                    } else {
                      lowp vec3 point_331;
                      point_331 = position_223;
                      lowp vec3 ray_dir_332;
                      ray_dir_332 = tmpvar_219;
                      lowp vec3 normal_333;
                      normal_333 = normal_224;
                      vec3 diffuseColor_334;
                      diffuseColor_334 = indirectDiffuseColor_214;
                      vec3 specularColor_335;
                      specularColor_335 = specularColor_226;
                      highp int i_336;
                      lowp vec3 illuminationColor_337;
                      i_336 = 0;
                      while (true) {
                        highp int k_338;
                        bool inShade_339;
                        highp int areaShadowSamples_340;
                        lowp vec3 light_sum_341;
                        vec2 lightSpot_342;
                        vec2 lightSize_343;
                        vec3 lightIntensity_344;
                        vec3 lightPos_345;
                        if ((i_336 >= 2)) {
                          break;
                        };
                        if ((i_336 == numLights)) {
                          break;
                        };
                        lightPos_345 = lightPos[i_336];
                        lightIntensity_344 = lightIntensity[i_336];
                        lightSize_343 = lightSize[i_336];
                        lightSpot_342 = lightSpot[i_336];
                        areaShadowSamples_340 = 0;
                        inShade_339 = bool(0);
                        k_338 = 0;
                        while (true) {
                          vec3 testPos_346;
                          if ((k_338 >= 5)) {
                            break;
                          };
                          if (inShade_339) {
                            break;
                          };
                          if ((k_338 == 1)) {
                            break;
                          };
                          testPos_346 = lightPos_345;
                          if ((k_338 == 1)) {
                            testPos_346.x = (lightPos_345.x - (lightSize_343.x * 0.5));
                            testPos_346.z = (lightPos_345.z - (lightSize_343.y * 0.5));
                          } else {
                            if ((k_338 == 2)) {
                              testPos_346.x = (testPos_346.x + (lightSize_343.x * 0.5));
                              testPos_346.z = (testPos_346.z + (lightSize_343.y * 0.5));
                            } else {
                              if ((k_338 == 3)) {
                                testPos_346.x = (testPos_346.x + (lightSize_343.x * 0.5));
                                testPos_346.z = (testPos_346.z - (lightSize_343.y * 0.5));
                              } else {
                                if ((k_338 == 4)) {
                                  testPos_346.x = (testPos_346.x - (lightSize_343.x * 0.5));
                                  testPos_346.z = (testPos_346.z + (lightSize_343.y * 0.5));
                                };
                              };
                            };
                          };
                          lowp vec3 vec_to_light_347;
                          lowp vec3 incident_intensity_348;
                          lowp float spot_falloff_349;
                          vec_to_light_347 = (testPos_346 - point_331);
                          lowp float tmpvar_350;
                          tmpvar_350 = sqrt(dot (vec_to_light_347, vec_to_light_347));
                          lowp float tmpvar_351;
                          tmpvar_351 = (1.0/(((attenuation.x * 
                            (tmpvar_350 * tmpvar_350)
                          ) + (attenuation.y * tmpvar_350))));
                          lowp vec3 tmpvar_352;
                          tmpvar_352 = normalize(vec_to_light_347);
                          vec_to_light_347 = tmpvar_352;
                          spot_falloff_349 = 1.0;
                          if ((lightSpot_342.x > 0.0)) {
                            lowp float tmpvar_353;
                            if ((tmpvar_352.y > lightSpot_342.x)) {
                              tmpvar_353 = pow (tmpvar_352.y, lightSpot_342.y);
                            } else {
                              tmpvar_353 = 0.0;
                            };
                            spot_falloff_349 = tmpvar_353;
                          };
                          incident_intensity_348 = ((lightIntensity_344 * tmpvar_351) * spot_falloff_349);
                          lowp float tmpvar_354;
                          tmpvar_354 = sqrt(dot (incident_intensity_348, incident_intensity_348));
                          if ((tmpvar_354 > 0.01)) {
                            lowp vec3 ray_origin_355;
                            ray_origin_355 = point_331;
                            lowp vec3 ray_direction_356;
                            ray_direction_356 = tmpvar_352;
                            lowp float t_hit_357;
                            t_hit_357 = tmpvar_350;
                            bool tmpvar_358;
                            tmpvar_358 = bool(0);
                            highp int i_359;
                            highp int i_360;
                            i_360 = 0;
                            while (true) {
                              if ((i_360 >= 5)) {
                                break;
                              };
                              if ((i_360 == numSpheres)) {
                                break;
                              };
                              lowp float t_hit_361;
                              t_hit_361 = t_hit_357;
                              bool tmpvar_362;
                              lowp vec3 tmpvar_363;
                              tmpvar_363 = (sphereCenters[i_360] - ray_origin_355);
                              lowp float tmpvar_364;
                              tmpvar_364 = dot (tmpvar_363, ray_direction_356);
                              if ((tmpvar_364 < 0.0)) {
                                tmpvar_362 = bool(0);
                              } else {
                                lowp float tmpvar_365;
                                tmpvar_365 = (dot (tmpvar_363, tmpvar_363) - (tmpvar_364 * tmpvar_364));
                                if ((tmpvar_365 > 0.64)) {
                                  tmpvar_362 = bool(0);
                                } else {
                                  lowp float tmpvar_366;
                                  tmpvar_366 = sqrt((0.64 - tmpvar_365));
                                  lowp float tmpvar_367;
                                  tmpvar_367 = (tmpvar_364 - tmpvar_366);
                                  lowp float tmpvar_368;
                                  tmpvar_368 = (tmpvar_364 + tmpvar_366);
                                  lowp float tmpvar_369;
                                  if ((tmpvar_367 < 0.01)) {
                                    tmpvar_369 = tmpvar_368;
                                  } else {
                                    tmpvar_369 = tmpvar_367;
                                  };
                                  if (((tmpvar_369 < t_hit_357) && (tmpvar_369 > 0.01))) {
                                    t_hit_361 = tmpvar_369;
                                    tmpvar_362 = bool(1);
                                  } else {
                                    tmpvar_362 = bool(0);
                                  };
                                };
                              };
                              t_hit_357 = t_hit_361;
                              if (tmpvar_362) {
                                tmpvar_358 = bool(1);
                                break;
                              };
                              i_360++;
                            };
                            if (!(tmpvar_358)) {
                              i_359 = 0;
                              while (true) {
                                if ((i_359 >= 6)) {
                                  break;
                                };
                                if ((i_359 == numPlanes)) {
                                  break;
                                };
                                vec3 normal_370;
                                normal_370 = planeNormals[i_359];
                                lowp float t_hit_371;
                                t_hit_371 = t_hit_357;
                                bool tmpvar_372;
                                tmpvar_372 = bool(1);
                                bool tmpvar_373;
                                vec3 tmpvar_374;
                                tmpvar_374 = (normal_370 * planeOffsets[i_359]);
                                lowp float tmpvar_375;
                                tmpvar_375 = (((
                                  (tmpvar_374.x + tmpvar_374.y)
                                 + tmpvar_374.z) - dot (normal_370, ray_origin_355)) / dot (normal_370, ray_direction_356));
                                if (((tmpvar_375 < t_hit_357) && (tmpvar_375 > 0.01))) {
                                  t_hit_371 = tmpvar_375;
                                  tmpvar_373 = bool(1);
                                  tmpvar_372 = bool(0);
                                };
                                if (tmpvar_372) {
                                  tmpvar_373 = bool(0);
                                  tmpvar_372 = bool(0);
                                };
                                t_hit_357 = t_hit_371;
                                if (tmpvar_373) {
                                  tmpvar_358 = bool(1);
                                  break;
                                };
                                i_359++;
                              };
                              if (!(tmpvar_358)) {
                                tmpvar_358 = bool(1);
                              };
                            };
                            lowp float tmpvar_376;
                            tmpvar_376 = abs((t_hit_357 - tmpvar_350));
                            if ((tmpvar_376 < 0.001)) {
                              lowp vec3 tmpvar_377;
                              lowp float tmpvar_378;
                              tmpvar_378 = dot (normal_333, tmpvar_352);
                              if ((tmpvar_378 > 0.0)) {
                                tmpvar_377 = (incident_intensity_348 * ((diffuseColor_334 * 
                                  max (0.0, dot (normal_333, tmpvar_352))
                                ) + (specularColor_335 * 
                                  pow (max (0.0, dot ((
                                    -(tmpvar_352)
                                   - 
                                    ((2.0 * dot (-(tmpvar_352), normal_333)) * normal_333)
                                  ), -(ray_dir_332))), 32.0)
                                )));
                              } else {
                                tmpvar_377 = vec3(0.0, 0.0, 0.0);
                              };
                              light_sum_341 = (light_sum_341 + tmpvar_377);
                            } else {
                              inShade_339 = bool(1);
                            };
                          } else {
                            inShade_339 = bool(1);
                          };
                          areaShadowSamples_340++;
                          k_338++;
                        };
                        illuminationColor_337 = (illuminationColor_337 + (light_sum_341 / float(areaShadowSamples_340)));
                        i_336++;
                      };
                      tmpvar_330 = illuminationColor_337;
                    };
                    indirect_sampling_sum_209 = (indirect_sampling_sum_209 + tmpvar_330);
                    k_208++;
                  };
                  tmpvar_207 = ((indirect_sampling_sum_209 / float(indirectSamples)) * diffuseColor_12);
                };
                pixelColor_5 = (pixelColor_5 + tmpvar_207);
              };
              bool tmpvar_379;
              if ((rayBounces > 0)) {
                tmpvar_379 = (sqrt(dot (reflectiveColor_14, reflectiveColor_14)) > 0.0);
              } else {
                tmpvar_379 = bool(0);
              };
              if (tmpvar_379) {
                lowp vec3 origin_380;
                origin_380 = position_10;
                lowp vec3 rayDir_381;
                rayDir_381 = tmpvar_6;
                lowp vec3 normal_382;
                normal_382 = normal_11;
                vec3 refColor_383;
                refColor_383 = reflectiveColor_14;
                lowp vec3 reflectionSum_385;
                for (highp int i_384 = 0; i_384 < 5; i_384++) {
                  lowp vec3 mirror_sample_color_386;
                  float hitRoughness_387;
                  vec3 bounceRefColor_388;
                  vec3 bounceSpecularColor_389;
                  vec3 bounceDiffuseColor_390;
                  bool tmpvar_391;
                  if ((i_384 >= rayBounces)) {
                    tmpvar_391 = bool(1);
                  } else {
                    tmpvar_391 = (sqrt(dot (refColor_383, refColor_383)) == 0.0);
                  };
                  if (tmpvar_391) {
                    break;
                  };
                  lowp vec3 tmpvar_392;
                  tmpvar_392 = (rayDir_381 - (2.0 * (
                    dot (normal_382, rayDir_381)
                   * normal_382)));
                  lowp vec3 ray_origin_393;
                  ray_origin_393 = origin_380;
                  lowp vec3 ray_direction_394;
                  ray_direction_394 = tmpvar_392;
                  lowp float t_hit_395;
                  t_hit_395 = 50.0;
                  lowp vec3 position_396;
                  lowp vec3 normal_397;
                  vec3 diffuseColor_398;
                  diffuseColor_398 = bounceDiffuseColor_390;
                  vec3 specularColor_399;
                  specularColor_399 = bounceSpecularColor_389;
                  vec3 reflectiveColor_400;
                  reflectiveColor_400 = bounceRefColor_388;
                  float roughness_401;
                  roughness_401 = hitRoughness_387;
                  bool isLight_402;
                  isLight_402 = bool(0);
                  highp int i_403;
                  highp int i_404;
                  highp int i_405;
                  highp int idx_406;
                  highp int intersected_407;
                  intersected_407 = 0;
                  idx_406 = 0;
                  i_405 = 0;
                  if ((0 < numSpheres)) {
                    lowp float t_hit_408;
                    t_hit_408 = t_hit_395;
                    bool tmpvar_409;
                    lowp vec3 tmpvar_410;
                    tmpvar_410 = (sphereCenters[0] - origin_380);
                    lowp float tmpvar_411;
                    tmpvar_411 = dot (tmpvar_410, tmpvar_392);
                    if ((tmpvar_411 < 0.0)) {
                      tmpvar_409 = bool(0);
                    } else {
                      lowp float tmpvar_412;
                      tmpvar_412 = (dot (tmpvar_410, tmpvar_410) - (tmpvar_411 * tmpvar_411));
                      if ((tmpvar_412 > 0.64)) {
                        tmpvar_409 = bool(0);
                      } else {
                        lowp float tmpvar_413;
                        tmpvar_413 = sqrt((0.64 - tmpvar_412));
                        lowp float tmpvar_414;
                        tmpvar_414 = (tmpvar_411 - tmpvar_413);
                        lowp float tmpvar_415;
                        tmpvar_415 = (tmpvar_411 + tmpvar_413);
                        lowp float tmpvar_416;
                        if ((tmpvar_414 < 0.01)) {
                          tmpvar_416 = tmpvar_415;
                        } else {
                          tmpvar_416 = tmpvar_414;
                        };
                        if (((tmpvar_416 < 50.0) && (tmpvar_416 > 0.01))) {
                          t_hit_408 = tmpvar_416;
                          tmpvar_409 = bool(1);
                        } else {
                          tmpvar_409 = bool(0);
                        };
                      };
                    };
                    t_hit_395 = t_hit_408;
                    if (tmpvar_409) {
                      idx_406 = i_405;
                      intersected_407 = 1;
                    };
                    i_405 = 1;
                    if ((1 < numSpheres)) {
                      lowp float t_hit_417;
                      t_hit_417 = t_hit_408;
                      bool tmpvar_418;
                      lowp vec3 tmpvar_419;
                      tmpvar_419 = (sphereCenters[1] - origin_380);
                      lowp float tmpvar_420;
                      tmpvar_420 = dot (tmpvar_419, tmpvar_392);
                      if ((tmpvar_420 < 0.0)) {
                        tmpvar_418 = bool(0);
                      } else {
                        lowp float tmpvar_421;
                        tmpvar_421 = (dot (tmpvar_419, tmpvar_419) - (tmpvar_420 * tmpvar_420));
                        if ((tmpvar_421 > 0.64)) {
                          tmpvar_418 = bool(0);
                        } else {
                          lowp float tmpvar_422;
                          tmpvar_422 = sqrt((0.64 - tmpvar_421));
                          lowp float tmpvar_423;
                          tmpvar_423 = (tmpvar_420 - tmpvar_422);
                          lowp float tmpvar_424;
                          tmpvar_424 = (tmpvar_420 + tmpvar_422);
                          lowp float tmpvar_425;
                          if ((tmpvar_423 < 0.01)) {
                            tmpvar_425 = tmpvar_424;
                          } else {
                            tmpvar_425 = tmpvar_423;
                          };
                          if (((tmpvar_425 < t_hit_408) && (tmpvar_425 > 0.01))) {
                            t_hit_417 = tmpvar_425;
                            tmpvar_418 = bool(1);
                          } else {
                            tmpvar_418 = bool(0);
                          };
                        };
                      };
                      t_hit_395 = t_hit_417;
                      if (tmpvar_418) {
                        idx_406 = i_405;
                        intersected_407 = 1;
                      };
                      i_405 = 2;
                      if ((2 < numSpheres)) {
                        lowp float t_hit_426;
                        t_hit_426 = t_hit_417;
                        bool tmpvar_427;
                        lowp vec3 tmpvar_428;
                        tmpvar_428 = (sphereCenters[2] - origin_380);
                        lowp float tmpvar_429;
                        tmpvar_429 = dot (tmpvar_428, tmpvar_392);
                        if ((tmpvar_429 < 0.0)) {
                          tmpvar_427 = bool(0);
                        } else {
                          lowp float tmpvar_430;
                          tmpvar_430 = (dot (tmpvar_428, tmpvar_428) - (tmpvar_429 * tmpvar_429));
                          if ((tmpvar_430 > 0.64)) {
                            tmpvar_427 = bool(0);
                          } else {
                            lowp float tmpvar_431;
                            tmpvar_431 = sqrt((0.64 - tmpvar_430));
                            lowp float tmpvar_432;
                            tmpvar_432 = (tmpvar_429 - tmpvar_431);
                            lowp float tmpvar_433;
                            tmpvar_433 = (tmpvar_429 + tmpvar_431);
                            lowp float tmpvar_434;
                            if ((tmpvar_432 < 0.01)) {
                              tmpvar_434 = tmpvar_433;
                            } else {
                              tmpvar_434 = tmpvar_432;
                            };
                            if (((tmpvar_434 < t_hit_417) && (tmpvar_434 > 0.01))) {
                              t_hit_426 = tmpvar_434;
                              tmpvar_427 = bool(1);
                            } else {
                              tmpvar_427 = bool(0);
                            };
                          };
                        };
                        t_hit_395 = t_hit_426;
                        if (tmpvar_427) {
                          idx_406 = i_405;
                          intersected_407 = 1;
                        };
                        i_405 = 3;
                        if ((3 < numSpheres)) {
                          lowp float t_hit_435;
                          t_hit_435 = t_hit_426;
                          bool tmpvar_436;
                          lowp vec3 tmpvar_437;
                          tmpvar_437 = (sphereCenters[3] - origin_380);
                          lowp float tmpvar_438;
                          tmpvar_438 = dot (tmpvar_437, tmpvar_392);
                          if ((tmpvar_438 < 0.0)) {
                            tmpvar_436 = bool(0);
                          } else {
                            lowp float tmpvar_439;
                            tmpvar_439 = (dot (tmpvar_437, tmpvar_437) - (tmpvar_438 * tmpvar_438));
                            if ((tmpvar_439 > 0.64)) {
                              tmpvar_436 = bool(0);
                            } else {
                              lowp float tmpvar_440;
                              tmpvar_440 = sqrt((0.64 - tmpvar_439));
                              lowp float tmpvar_441;
                              tmpvar_441 = (tmpvar_438 - tmpvar_440);
                              lowp float tmpvar_442;
                              tmpvar_442 = (tmpvar_438 + tmpvar_440);
                              lowp float tmpvar_443;
                              if ((tmpvar_441 < 0.01)) {
                                tmpvar_443 = tmpvar_442;
                              } else {
                                tmpvar_443 = tmpvar_441;
                              };
                              if (((tmpvar_443 < t_hit_426) && (tmpvar_443 > 0.01))) {
                                t_hit_435 = tmpvar_443;
                                tmpvar_436 = bool(1);
                              } else {
                                tmpvar_436 = bool(0);
                              };
                            };
                          };
                          t_hit_395 = t_hit_435;
                          if (tmpvar_436) {
                            idx_406 = i_405;
                            intersected_407 = 1;
                          };
                          i_405 = 4;
                          if ((4 < numSpheres)) {
                            lowp float t_hit_444;
                            t_hit_444 = t_hit_435;
                            bool tmpvar_445;
                            lowp vec3 tmpvar_446;
                            tmpvar_446 = (sphereCenters[4] - origin_380);
                            lowp float tmpvar_447;
                            tmpvar_447 = dot (tmpvar_446, tmpvar_392);
                            if ((tmpvar_447 < 0.0)) {
                              tmpvar_445 = bool(0);
                            } else {
                              lowp float tmpvar_448;
                              tmpvar_448 = (dot (tmpvar_446, tmpvar_446) - (tmpvar_447 * tmpvar_447));
                              if ((tmpvar_448 > 0.64)) {
                                tmpvar_445 = bool(0);
                              } else {
                                lowp float tmpvar_449;
                                tmpvar_449 = sqrt((0.64 - tmpvar_448));
                                lowp float tmpvar_450;
                                tmpvar_450 = (tmpvar_447 - tmpvar_449);
                                lowp float tmpvar_451;
                                tmpvar_451 = (tmpvar_447 + tmpvar_449);
                                lowp float tmpvar_452;
                                if ((tmpvar_450 < 0.01)) {
                                  tmpvar_452 = tmpvar_451;
                                } else {
                                  tmpvar_452 = tmpvar_450;
                                };
                                if (((tmpvar_452 < t_hit_435) && (tmpvar_452 > 0.01))) {
                                  t_hit_444 = tmpvar_452;
                                  tmpvar_445 = bool(1);
                                } else {
                                  tmpvar_445 = bool(0);
                                };
                              };
                            };
                            t_hit_395 = t_hit_444;
                            if (tmpvar_445) {
                              idx_406 = i_405;
                              intersected_407 = 1;
                            };
                            i_405 = 5;
                          };
                        };
                      };
                    };
                  };
                  i_404 = 0;
                  while (true) {
                    bool tmp_453;
                    if ((i_404 >= 6)) {
                      break;
                    };
                    if ((i_404 >= numPlanes)) {
                      break;
                    };
                    lowp vec3 tmpvar_454;
                    tmpvar_454 = planeNormals[i_404];
                    tmp_453 = bool(0);
                    bool tmpvar_455;
                    if (enablePlaneBacksides) {
                      tmpvar_455 = bool(1);
                    } else {
                      tmpvar_455 = (dot (ray_direction_394, tmpvar_454) < 0.0);
                    };
                    if (tmpvar_455) {
                      lowp float t_hit_456;
                      t_hit_456 = t_hit_395;
                      bool tmpvar_457;
                      tmpvar_457 = bool(1);
                      bool tmpvar_458;
                      lowp vec3 tmpvar_459;
                      tmpvar_459 = (tmpvar_454 * planeOffsets[i_404]);
                      lowp float tmpvar_460;
                      tmpvar_460 = (((
                        (tmpvar_459.x + tmpvar_459.y)
                       + tmpvar_459.z) - dot (tmpvar_454, ray_origin_393)) / dot (tmpvar_454, ray_direction_394));
                      if (((tmpvar_460 < t_hit_395) && (tmpvar_460 > 0.01))) {
                        t_hit_456 = tmpvar_460;
                        tmpvar_458 = bool(1);
                        tmpvar_457 = bool(0);
                      };
                      if (tmpvar_457) {
                        tmpvar_458 = bool(0);
                        tmpvar_457 = bool(0);
                      };
                      t_hit_395 = t_hit_456;
                      tmp_453 = tmpvar_458;
                    };
                    if (tmp_453) {
                      normal_397 = tmpvar_454;
                      idx_406 = i_404;
                      intersected_407 = 2;
                    };
                    i_404++;
                  };
                  i_403 = 0;
                  bool tmp_461;
                  if ((0 < numLights)) {
                    vec3 tmpvar_462;
                    tmpvar_462 = lightPos[0];
                    vec2 tmpvar_463;
                    tmpvar_463 = lightSize[0];
                    tmp_461 = bool(0);
                    if (((tmpvar_463.x > 0.0) && (tmpvar_463.y > 0.0))) {
                      lowp float t_hit_464;
                      t_hit_464 = t_hit_395;
                      bool tmpvar_465;
                      tmpvar_465 = bool(1);
                      bool tmpvar_466;
                      vec3 tmpvar_467;
                      tmpvar_467 = (vec3(0.0, 1.0, 0.0) * tmpvar_462.y);
                      lowp float tmpvar_468;
                      tmpvar_468 = (((
                        (tmpvar_467.x + tmpvar_467.y)
                       + tmpvar_467.z) - origin_380.y) / tmpvar_392.y);
                      if (((tmpvar_468 < t_hit_395) && (tmpvar_468 > 0.01))) {
                        lowp vec3 tmpvar_469;
                        tmpvar_469 = (origin_380 + (tmpvar_392 * tmpvar_468));
                        float tmpvar_470;
                        tmpvar_470 = sqrt(dot (tmpvar_463, tmpvar_463));
                        if (((tmpvar_470 == 0.0) || ((
                          ((tmpvar_469.x < (tmpvar_462.x + (tmpvar_463.x * 0.5))) && (tmpvar_469.x > (tmpvar_462.x - (tmpvar_463.x * 0.5))))
                         && 
                          (tmpvar_469.z < (tmpvar_462.z + (tmpvar_463.y * 0.5)))
                        ) && (tmpvar_469.z > 
                          (tmpvar_462.z - (tmpvar_463.y * 0.5))
                        )))) {
                          t_hit_464 = tmpvar_468;
                          tmpvar_466 = bool(1);
                          tmpvar_465 = bool(0);
                        };
                      };
                      if (tmpvar_465) {
                        tmpvar_466 = bool(0);
                        tmpvar_465 = bool(0);
                      };
                      t_hit_395 = t_hit_464;
                      tmp_461 = tmpvar_466;
                    } else {
                      lowp float t_hit_471;
                      t_hit_471 = t_hit_395;
                      bool tmpvar_472;
                      lowp vec3 tmpvar_473;
                      tmpvar_473 = (tmpvar_462 - origin_380);
                      lowp float tmpvar_474;
                      tmpvar_474 = dot (tmpvar_473, tmpvar_392);
                      if ((tmpvar_474 < 0.0)) {
                        tmpvar_472 = bool(0);
                      } else {
                        lowp float tmpvar_475;
                        tmpvar_475 = (dot (tmpvar_473, tmpvar_473) - (tmpvar_474 * tmpvar_474));
                        if ((tmpvar_475 > 0.01)) {
                          tmpvar_472 = bool(0);
                        } else {
                          lowp float tmpvar_476;
                          tmpvar_476 = sqrt((0.01 - tmpvar_475));
                          lowp float tmpvar_477;
                          tmpvar_477 = (tmpvar_474 - tmpvar_476);
                          lowp float tmpvar_478;
                          tmpvar_478 = (tmpvar_474 + tmpvar_476);
                          lowp float tmpvar_479;
                          if ((tmpvar_477 < 0.01)) {
                            tmpvar_479 = tmpvar_478;
                          } else {
                            tmpvar_479 = tmpvar_477;
                          };
                          if (((tmpvar_479 < t_hit_395) && (tmpvar_479 > 0.01))) {
                            t_hit_471 = tmpvar_479;
                            tmpvar_472 = bool(1);
                          } else {
                            tmpvar_472 = bool(0);
                          };
                        };
                      };
                      t_hit_395 = t_hit_471;
                      tmp_461 = tmpvar_472;
                    };
                    if (tmp_461) {
                      idx_406 = i_403;
                      intersected_407 = 3;
                    };
                    i_403 = 1;
                    bool tmp_480;
                    if ((1 < numLights)) {
                      vec3 tmpvar_481;
                      tmpvar_481 = lightPos[1];
                      vec2 tmpvar_482;
                      tmpvar_482 = lightSize[1];
                      tmp_480 = bool(0);
                      if (((tmpvar_482.x > 0.0) && (tmpvar_482.y > 0.0))) {
                        lowp float t_hit_483;
                        t_hit_483 = t_hit_395;
                        bool tmpvar_484;
                        tmpvar_484 = bool(1);
                        bool tmpvar_485;
                        vec3 tmpvar_486;
                        tmpvar_486 = (vec3(0.0, 1.0, 0.0) * tmpvar_481.y);
                        lowp float tmpvar_487;
                        tmpvar_487 = (((
                          (tmpvar_486.x + tmpvar_486.y)
                         + tmpvar_486.z) - origin_380.y) / tmpvar_392.y);
                        if (((tmpvar_487 < t_hit_395) && (tmpvar_487 > 0.01))) {
                          lowp vec3 tmpvar_488;
                          tmpvar_488 = (origin_380 + (tmpvar_392 * tmpvar_487));
                          float tmpvar_489;
                          tmpvar_489 = sqrt(dot (tmpvar_482, tmpvar_482));
                          if (((tmpvar_489 == 0.0) || ((
                            ((tmpvar_488.x < (tmpvar_481.x + (tmpvar_482.x * 0.5))) && (tmpvar_488.x > (tmpvar_481.x - (tmpvar_482.x * 0.5))))
                           && 
                            (tmpvar_488.z < (tmpvar_481.z + (tmpvar_482.y * 0.5)))
                          ) && (tmpvar_488.z > 
                            (tmpvar_481.z - (tmpvar_482.y * 0.5))
                          )))) {
                            t_hit_483 = tmpvar_487;
                            tmpvar_485 = bool(1);
                            tmpvar_484 = bool(0);
                          };
                        };
                        if (tmpvar_484) {
                          tmpvar_485 = bool(0);
                          tmpvar_484 = bool(0);
                        };
                        t_hit_395 = t_hit_483;
                        tmp_480 = tmpvar_485;
                      } else {
                        lowp float t_hit_490;
                        t_hit_490 = t_hit_395;
                        bool tmpvar_491;
                        lowp vec3 tmpvar_492;
                        tmpvar_492 = (tmpvar_481 - origin_380);
                        lowp float tmpvar_493;
                        tmpvar_493 = dot (tmpvar_492, tmpvar_392);
                        if ((tmpvar_493 < 0.0)) {
                          tmpvar_491 = bool(0);
                        } else {
                          lowp float tmpvar_494;
                          tmpvar_494 = (dot (tmpvar_492, tmpvar_492) - (tmpvar_493 * tmpvar_493));
                          if ((tmpvar_494 > 0.01)) {
                            tmpvar_491 = bool(0);
                          } else {
                            lowp float tmpvar_495;
                            tmpvar_495 = sqrt((0.01 - tmpvar_494));
                            lowp float tmpvar_496;
                            tmpvar_496 = (tmpvar_493 - tmpvar_495);
                            lowp float tmpvar_497;
                            tmpvar_497 = (tmpvar_493 + tmpvar_495);
                            lowp float tmpvar_498;
                            if ((tmpvar_496 < 0.01)) {
                              tmpvar_498 = tmpvar_497;
                            } else {
                              tmpvar_498 = tmpvar_496;
                            };
                            if (((tmpvar_498 < t_hit_395) && (tmpvar_498 > 0.01))) {
                              t_hit_490 = tmpvar_498;
                              tmpvar_491 = bool(1);
                            } else {
                              tmpvar_491 = bool(0);
                            };
                          };
                        };
                        t_hit_395 = t_hit_490;
                        tmp_480 = tmpvar_491;
                      };
                      if (tmp_480) {
                        idx_406 = i_403;
                        intersected_407 = 3;
                      };
                      i_403 = 2;
                    };
                  };
                  position_396 = (origin_380 + (tmpvar_392 * t_hit_395));
                  if ((intersected_407 == 1)) {
                    diffuseColor_398 = sphereColors[idx_406];
                    specularColor_399 = sphereSpecColors[idx_406];
                    reflectiveColor_400 = reflectiveColors[idx_406];
                    roughness_401 = sphereRoughness[idx_406];
                    lowp vec3 tmpvar_499;
                    tmpvar_499 = normalize((position_396 - sphereCenters[idx_406]));
                    normal_397 = tmpvar_499;
                    lowp float tmpvar_500;
                    tmpvar_500 = dot (tmpvar_499, -(tmpvar_392));
                    if ((tmpvar_500 < 0.0)) {
                      normal_397 = -(tmpvar_499);
                    };
                  } else {
                    if ((intersected_407 == 2)) {
                      if (enablePlaneMirrors) {
                        diffuseColor_398 = (planeColors[idx_406] * 0.01);
                        specularColor_399 = vec3(0.0, 0.0, 0.0);
                        reflectiveColor_400 = planeColors[idx_406];
                        roughness_401 = 1.0;
                      } else {
                        diffuseColor_398 = planeColors[idx_406];
                        specularColor_399 = vec3(0.0, 0.0, 0.0);
                        reflectiveColor_400 = vec3(0.0, 0.0, 0.0);
                        roughness_401 = planeRoughness[idx_406];
                      };
                      lowp float tmpvar_501;
                      tmpvar_501 = dot (normal_397, -(tmpvar_392));
                      if ((tmpvar_501 < 0.0)) {
                        normal_397 = -(normal_397);
                      };
                    } else {
                      if ((intersected_407 == 3)) {
                        diffuseColor_398 = (lightIntensity[idx_406] / 25.0);
                        isLight_402 = bool(1);
                      };
                    };
                  };
                  normal_382 = normal_397;
                  bounceDiffuseColor_390 = diffuseColor_398;
                  bounceSpecularColor_389 = specularColor_399;
                  bounceRefColor_388 = reflectiveColor_400;
                  hitRoughness_387 = roughness_401;
                  lowp vec3 tmpvar_502;
                  if (isLight_402) {
                    tmpvar_502 = diffuseColor_398;
                  } else {
                    lowp vec3 point_503;
                    point_503 = position_396;
                    lowp vec3 ray_dir_504;
                    ray_dir_504 = tmpvar_392;
                    lowp vec3 normal_505;
                    normal_505 = normal_397;
                    vec3 diffuseColor_506;
                    diffuseColor_506 = diffuseColor_398;
                    vec3 specularColor_507;
                    specularColor_507 = specularColor_399;
                    highp int i_508;
                    lowp vec3 illuminationColor_509;
                    i_508 = 0;
                    while (true) {
                      highp int k_510;
                      bool inShade_511;
                      highp int areaShadowSamples_512;
                      lowp vec3 light_sum_513;
                      vec2 lightSpot_514;
                      vec2 lightSize_515;
                      vec3 lightIntensity_516;
                      vec3 lightPos_517;
                      if ((i_508 >= 2)) {
                        break;
                      };
                      if ((i_508 == numLights)) {
                        break;
                      };
                      lightPos_517 = lightPos[i_508];
                      lightIntensity_516 = lightIntensity[i_508];
                      lightSize_515 = lightSize[i_508];
                      lightSpot_514 = lightSpot[i_508];
                      areaShadowSamples_512 = 0;
                      inShade_511 = bool(0);
                      k_510 = 0;
                      while (true) {
                        vec3 testPos_518;
                        if ((k_510 >= 5)) {
                          break;
                        };
                        if (inShade_511) {
                          break;
                        };
                        if ((k_510 == 1)) {
                          break;
                        };
                        testPos_518 = lightPos_517;
                        if ((k_510 == 1)) {
                          testPos_518.x = (lightPos_517.x - (lightSize_515.x * 0.5));
                          testPos_518.z = (lightPos_517.z - (lightSize_515.y * 0.5));
                        } else {
                          if ((k_510 == 2)) {
                            testPos_518.x = (testPos_518.x + (lightSize_515.x * 0.5));
                            testPos_518.z = (testPos_518.z + (lightSize_515.y * 0.5));
                          } else {
                            if ((k_510 == 3)) {
                              testPos_518.x = (testPos_518.x + (lightSize_515.x * 0.5));
                              testPos_518.z = (testPos_518.z - (lightSize_515.y * 0.5));
                            } else {
                              if ((k_510 == 4)) {
                                testPos_518.x = (testPos_518.x - (lightSize_515.x * 0.5));
                                testPos_518.z = (testPos_518.z + (lightSize_515.y * 0.5));
                              };
                            };
                          };
                        };
                        lowp vec3 vec_to_light_519;
                        lowp vec3 incident_intensity_520;
                        lowp float spot_falloff_521;
                        vec_to_light_519 = (testPos_518 - point_503);
                        lowp float tmpvar_522;
                        tmpvar_522 = sqrt(dot (vec_to_light_519, vec_to_light_519));
                        lowp float tmpvar_523;
                        tmpvar_523 = (1.0/(((attenuation.x * 
                          (tmpvar_522 * tmpvar_522)
                        ) + (attenuation.y * tmpvar_522))));
                        lowp vec3 tmpvar_524;
                        tmpvar_524 = normalize(vec_to_light_519);
                        vec_to_light_519 = tmpvar_524;
                        spot_falloff_521 = 1.0;
                        if ((lightSpot_514.x > 0.0)) {
                          lowp float tmpvar_525;
                          if ((tmpvar_524.y > lightSpot_514.x)) {
                            tmpvar_525 = pow (tmpvar_524.y, lightSpot_514.y);
                          } else {
                            tmpvar_525 = 0.0;
                          };
                          spot_falloff_521 = tmpvar_525;
                        };
                        incident_intensity_520 = ((lightIntensity_516 * tmpvar_523) * spot_falloff_521);
                        lowp float tmpvar_526;
                        tmpvar_526 = sqrt(dot (incident_intensity_520, incident_intensity_520));
                        if ((tmpvar_526 > 0.01)) {
                          lowp vec3 ray_origin_527;
                          ray_origin_527 = point_503;
                          lowp vec3 ray_direction_528;
                          ray_direction_528 = tmpvar_524;
                          lowp float t_hit_529;
                          t_hit_529 = tmpvar_522;
                          bool tmpvar_530;
                          tmpvar_530 = bool(0);
                          highp int i_531;
                          highp int i_532;
                          i_532 = 0;
                          while (true) {
                            if ((i_532 >= 5)) {
                              break;
                            };
                            if ((i_532 == numSpheres)) {
                              break;
                            };
                            lowp float t_hit_533;
                            t_hit_533 = t_hit_529;
                            bool tmpvar_534;
                            lowp vec3 tmpvar_535;
                            tmpvar_535 = (sphereCenters[i_532] - ray_origin_527);
                            lowp float tmpvar_536;
                            tmpvar_536 = dot (tmpvar_535, ray_direction_528);
                            if ((tmpvar_536 < 0.0)) {
                              tmpvar_534 = bool(0);
                            } else {
                              lowp float tmpvar_537;
                              tmpvar_537 = (dot (tmpvar_535, tmpvar_535) - (tmpvar_536 * tmpvar_536));
                              if ((tmpvar_537 > 0.64)) {
                                tmpvar_534 = bool(0);
                              } else {
                                lowp float tmpvar_538;
                                tmpvar_538 = sqrt((0.64 - tmpvar_537));
                                lowp float tmpvar_539;
                                tmpvar_539 = (tmpvar_536 - tmpvar_538);
                                lowp float tmpvar_540;
                                tmpvar_540 = (tmpvar_536 + tmpvar_538);
                                lowp float tmpvar_541;
                                if ((tmpvar_539 < 0.01)) {
                                  tmpvar_541 = tmpvar_540;
                                } else {
                                  tmpvar_541 = tmpvar_539;
                                };
                                if (((tmpvar_541 < t_hit_529) && (tmpvar_541 > 0.01))) {
                                  t_hit_533 = tmpvar_541;
                                  tmpvar_534 = bool(1);
                                } else {
                                  tmpvar_534 = bool(0);
                                };
                              };
                            };
                            t_hit_529 = t_hit_533;
                            if (tmpvar_534) {
                              tmpvar_530 = bool(1);
                              break;
                            };
                            i_532++;
                          };
                          if (!(tmpvar_530)) {
                            i_531 = 0;
                            while (true) {
                              if ((i_531 >= 6)) {
                                break;
                              };
                              if ((i_531 == numPlanes)) {
                                break;
                              };
                              vec3 normal_542;
                              normal_542 = planeNormals[i_531];
                              lowp float t_hit_543;
                              t_hit_543 = t_hit_529;
                              bool tmpvar_544;
                              tmpvar_544 = bool(1);
                              bool tmpvar_545;
                              vec3 tmpvar_546;
                              tmpvar_546 = (normal_542 * planeOffsets[i_531]);
                              lowp float tmpvar_547;
                              tmpvar_547 = (((
                                (tmpvar_546.x + tmpvar_546.y)
                               + tmpvar_546.z) - dot (normal_542, ray_origin_527)) / dot (normal_542, ray_direction_528));
                              if (((tmpvar_547 < t_hit_529) && (tmpvar_547 > 0.01))) {
                                t_hit_543 = tmpvar_547;
                                tmpvar_545 = bool(1);
                                tmpvar_544 = bool(0);
                              };
                              if (tmpvar_544) {
                                tmpvar_545 = bool(0);
                                tmpvar_544 = bool(0);
                              };
                              t_hit_529 = t_hit_543;
                              if (tmpvar_545) {
                                tmpvar_530 = bool(1);
                                break;
                              };
                              i_531++;
                            };
                            if (!(tmpvar_530)) {
                              tmpvar_530 = bool(1);
                            };
                          };
                          lowp float tmpvar_548;
                          tmpvar_548 = abs((t_hit_529 - tmpvar_522));
                          if ((tmpvar_548 < 0.001)) {
                            lowp vec3 tmpvar_549;
                            lowp float tmpvar_550;
                            tmpvar_550 = dot (normal_505, tmpvar_524);
                            if ((tmpvar_550 > 0.0)) {
                              tmpvar_549 = (incident_intensity_520 * ((diffuseColor_506 * 
                                max (0.0, dot (normal_505, tmpvar_524))
                              ) + (specularColor_507 * 
                                pow (max (0.0, dot ((
                                  -(tmpvar_524)
                                 - 
                                  ((2.0 * dot (-(tmpvar_524), normal_505)) * normal_505)
                                ), -(ray_dir_504))), 32.0)
                              )));
                            } else {
                              tmpvar_549 = vec3(0.0, 0.0, 0.0);
                            };
                            light_sum_513 = (light_sum_513 + tmpvar_549);
                          } else {
                            inShade_511 = bool(1);
                          };
                        } else {
                          inShade_511 = bool(1);
                        };
                        areaShadowSamples_512++;
                        k_510++;
                      };
                      illuminationColor_509 = (illuminationColor_509 + (light_sum_513 / float(areaShadowSamples_512)));
                      i_508++;
                    };
                    tmpvar_502 = illuminationColor_509;
                  };
                  mirror_sample_color_386 = tmpvar_502;
                  if (enableRefGI) {
                    lowp vec3 point_551;
                    point_551 = position_396;
                    lowp vec3 rayDir_552;
                    rayDir_552 = tmpvar_392;
                    lowp vec3 normal_553;
                    normal_553 = normal_397;
                    float roughness_554;
                    roughness_554 = roughness_401;
                    lowp vec3 tmpvar_555;
                    highp int k_556;
                    lowp vec3 indirect_sampling_sum_557;
                    float tmpvar_558;
                    tmpvar_558 = sqrt(dot (diffuseColor_398, diffuseColor_398));
                    if ((tmpvar_558 == 0.0)) {
                      tmpvar_555 = vec3(0.0, 0.0, 0.0);
                    } else {
                      k_556 = 0;
                      while (true) {
                        float indirectRoughness_559;
                        vec3 indirectRefColor_560;
                        vec3 indirectSpecularColor_561;
                        vec3 indirectDiffuseColor_562;
                        if ((k_556 >= 100)) {
                          break;
                        };
                        if ((k_556 >= indirectSamples)) {
                          break;
                        };
                        randomIncrement += 0.02;
                        lowp float tmpvar_563;
                        tmpvar_563 = ((fract(
                          (cos(dot ((point_551.xy + randomIncrement), vec2(23.14069, 2.665144))) * 12345.68)
                        ) * 2.0) - 1.0);
                        randomIncrement += 0.02;
                        lowp float tmpvar_564;
                        tmpvar_564 = (fract((
                          cos(dot ((point_551.xy + randomIncrement), vec2(23.14069, 2.665144)))
                         * 12345.68)) * 6.283185);
                        lowp float tmpvar_565;
                        tmpvar_565 = sqrt((1.0 - (tmpvar_563 * tmpvar_563)));
                        lowp vec3 tmpvar_566;
                        tmpvar_566.x = (tmpvar_565 * cos(tmpvar_564));
                        tmpvar_566.y = (tmpvar_565 * sin(tmpvar_564));
                        tmpvar_566.z = tmpvar_563;
                        lowp vec3 tmpvar_567;
                        tmpvar_567 = normalize(mix ((rayDir_552 - 
                          (2.0 * (dot (normal_553, rayDir_552) * normal_553))
                        ), normalize(
                          (normal_553 + tmpvar_566)
                        ), roughness_554));
                        lowp vec3 ray_origin_568;
                        ray_origin_568 = point_551;
                        lowp vec3 ray_direction_569;
                        ray_direction_569 = tmpvar_567;
                        lowp float t_hit_570;
                        t_hit_570 = 10.0;
                        lowp vec3 position_571;
                        lowp vec3 normal_572;
                        vec3 diffuseColor_573;
                        diffuseColor_573 = indirectDiffuseColor_562;
                        vec3 specularColor_574;
                        specularColor_574 = indirectSpecularColor_561;
                        vec3 reflectiveColor_575;
                        reflectiveColor_575 = indirectRefColor_560;
                        float roughness_576;
                        roughness_576 = indirectRoughness_559;
                        bool isLight_577;
                        isLight_577 = bool(0);
                        highp int i_578;
                        highp int i_579;
                        highp int i_580;
                        highp int idx_581;
                        highp int intersected_582;
                        intersected_582 = 0;
                        idx_581 = 0;
                        i_580 = 0;
                        while (true) {
                          if ((i_580 >= 5)) {
                            break;
                          };
                          if ((i_580 >= numSpheres)) {
                            break;
                          };
                          lowp float t_hit_583;
                          t_hit_583 = t_hit_570;
                          bool tmpvar_584;
                          lowp vec3 tmpvar_585;
                          tmpvar_585 = (sphereCenters[i_580] - ray_origin_568);
                          lowp float tmpvar_586;
                          tmpvar_586 = dot (tmpvar_585, ray_direction_569);
                          if ((tmpvar_586 < 0.0)) {
                            tmpvar_584 = bool(0);
                          } else {
                            lowp float tmpvar_587;
                            tmpvar_587 = (dot (tmpvar_585, tmpvar_585) - (tmpvar_586 * tmpvar_586));
                            if ((tmpvar_587 > 0.64)) {
                              tmpvar_584 = bool(0);
                            } else {
                              lowp float tmpvar_588;
                              tmpvar_588 = sqrt((0.64 - tmpvar_587));
                              lowp float tmpvar_589;
                              tmpvar_589 = (tmpvar_586 - tmpvar_588);
                              lowp float tmpvar_590;
                              tmpvar_590 = (tmpvar_586 + tmpvar_588);
                              lowp float tmpvar_591;
                              if ((tmpvar_589 < 0.01)) {
                                tmpvar_591 = tmpvar_590;
                              } else {
                                tmpvar_591 = tmpvar_589;
                              };
                              if (((tmpvar_591 < t_hit_570) && (tmpvar_591 > 0.01))) {
                                t_hit_583 = tmpvar_591;
                                tmpvar_584 = bool(1);
                              } else {
                                tmpvar_584 = bool(0);
                              };
                            };
                          };
                          t_hit_570 = t_hit_583;
                          if (tmpvar_584) {
                            idx_581 = i_580;
                            intersected_582 = 1;
                          };
                          i_580++;
                        };
                        i_579 = 0;
                        while (true) {
                          bool tmp_592;
                          if ((i_579 >= 6)) {
                            break;
                          };
                          if ((i_579 >= numPlanes)) {
                            break;
                          };
                          lowp vec3 tmpvar_593;
                          tmpvar_593 = planeNormals[i_579];
                          tmp_592 = bool(0);
                          bool tmpvar_594;
                          if (enablePlaneBacksides) {
                            tmpvar_594 = bool(1);
                          } else {
                            tmpvar_594 = (dot (ray_direction_569, tmpvar_593) < 0.0);
                          };
                          if (tmpvar_594) {
                            lowp float t_hit_595;
                            t_hit_595 = t_hit_570;
                            bool tmpvar_596;
                            tmpvar_596 = bool(1);
                            bool tmpvar_597;
                            lowp vec3 tmpvar_598;
                            tmpvar_598 = (tmpvar_593 * planeOffsets[i_579]);
                            lowp float tmpvar_599;
                            tmpvar_599 = (((
                              (tmpvar_598.x + tmpvar_598.y)
                             + tmpvar_598.z) - dot (tmpvar_593, ray_origin_568)) / dot (tmpvar_593, ray_direction_569));
                            if (((tmpvar_599 < t_hit_570) && (tmpvar_599 > 0.01))) {
                              t_hit_595 = tmpvar_599;
                              tmpvar_597 = bool(1);
                              tmpvar_596 = bool(0);
                            };
                            if (tmpvar_596) {
                              tmpvar_597 = bool(0);
                              tmpvar_596 = bool(0);
                            };
                            t_hit_570 = t_hit_595;
                            tmp_592 = tmpvar_597;
                          };
                          if (tmp_592) {
                            normal_572 = tmpvar_593;
                            idx_581 = i_579;
                            intersected_582 = 2;
                          };
                          i_579++;
                        };
                        i_578 = 0;
                        while (true) {
                          bool tmp_600;
                          if ((i_578 >= 2)) {
                            break;
                          };
                          if ((i_578 >= numLights)) {
                            break;
                          };
                          vec3 tmpvar_601;
                          tmpvar_601 = lightPos[i_578];
                          vec2 tmpvar_602;
                          tmpvar_602 = lightSize[i_578];
                          tmp_600 = bool(0);
                          if (((tmpvar_602.x > 0.0) && (tmpvar_602.y > 0.0))) {
                            lowp float t_hit_603;
                            t_hit_603 = t_hit_570;
                            bool tmpvar_604;
                            tmpvar_604 = bool(1);
                            bool tmpvar_605;
                            vec3 tmpvar_606;
                            tmpvar_606 = (vec3(0.0, 1.0, 0.0) * tmpvar_601.y);
                            lowp float tmpvar_607;
                            tmpvar_607 = (((
                              (tmpvar_606.x + tmpvar_606.y)
                             + tmpvar_606.z) - ray_origin_568.y) / ray_direction_569.y);
                            if (((tmpvar_607 < t_hit_570) && (tmpvar_607 > 0.01))) {
                              lowp vec3 tmpvar_608;
                              tmpvar_608 = (ray_origin_568 + (ray_direction_569 * tmpvar_607));
                              float tmpvar_609;
                              tmpvar_609 = sqrt(dot (tmpvar_602, tmpvar_602));
                              if (((tmpvar_609 == 0.0) || ((
                                ((tmpvar_608.x < (tmpvar_601.x + (tmpvar_602.x * 0.5))) && (tmpvar_608.x > (tmpvar_601.x - (tmpvar_602.x * 0.5))))
                               && 
                                (tmpvar_608.z < (tmpvar_601.z + (tmpvar_602.y * 0.5)))
                              ) && (tmpvar_608.z > 
                                (tmpvar_601.z - (tmpvar_602.y * 0.5))
                              )))) {
                                t_hit_603 = tmpvar_607;
                                tmpvar_605 = bool(1);
                                tmpvar_604 = bool(0);
                              };
                            };
                            if (tmpvar_604) {
                              tmpvar_605 = bool(0);
                              tmpvar_604 = bool(0);
                            };
                            t_hit_570 = t_hit_603;
                            tmp_600 = tmpvar_605;
                          } else {
                            lowp float t_hit_610;
                            t_hit_610 = t_hit_570;
                            bool tmpvar_611;
                            lowp vec3 tmpvar_612;
                            tmpvar_612 = (tmpvar_601 - ray_origin_568);
                            lowp float tmpvar_613;
                            tmpvar_613 = dot (tmpvar_612, ray_direction_569);
                            if ((tmpvar_613 < 0.0)) {
                              tmpvar_611 = bool(0);
                            } else {
                              lowp float tmpvar_614;
                              tmpvar_614 = (dot (tmpvar_612, tmpvar_612) - (tmpvar_613 * tmpvar_613));
                              if ((tmpvar_614 > 0.01)) {
                                tmpvar_611 = bool(0);
                              } else {
                                lowp float tmpvar_615;
                                tmpvar_615 = sqrt((0.01 - tmpvar_614));
                                lowp float tmpvar_616;
                                tmpvar_616 = (tmpvar_613 - tmpvar_615);
                                lowp float tmpvar_617;
                                tmpvar_617 = (tmpvar_613 + tmpvar_615);
                                lowp float tmpvar_618;
                                if ((tmpvar_616 < 0.01)) {
                                  tmpvar_618 = tmpvar_617;
                                } else {
                                  tmpvar_618 = tmpvar_616;
                                };
                                if (((tmpvar_618 < t_hit_570) && (tmpvar_618 > 0.01))) {
                                  t_hit_610 = tmpvar_618;
                                  tmpvar_611 = bool(1);
                                } else {
                                  tmpvar_611 = bool(0);
                                };
                              };
                            };
                            t_hit_570 = t_hit_610;
                            tmp_600 = tmpvar_611;
                          };
                          if (tmp_600) {
                            idx_581 = i_578;
                            intersected_582 = 3;
                          };
                          i_578++;
                        };
                        position_571 = (point_551 + (tmpvar_567 * t_hit_570));
                        if ((intersected_582 == 1)) {
                          diffuseColor_573 = sphereColors[idx_581];
                          specularColor_574 = sphereSpecColors[idx_581];
                          reflectiveColor_575 = reflectiveColors[idx_581];
                          roughness_576 = sphereRoughness[idx_581];
                          lowp vec3 tmpvar_619;
                          tmpvar_619 = normalize((position_571 - sphereCenters[idx_581]));
                          normal_572 = tmpvar_619;
                          lowp float tmpvar_620;
                          tmpvar_620 = dot (tmpvar_619, -(tmpvar_567));
                          if ((tmpvar_620 < 0.0)) {
                            normal_572 = -(tmpvar_619);
                          };
                        } else {
                          if ((intersected_582 == 2)) {
                            if (enablePlaneMirrors) {
                              diffuseColor_573 = (planeColors[idx_581] * 0.01);
                              specularColor_574 = vec3(0.0, 0.0, 0.0);
                              reflectiveColor_575 = planeColors[idx_581];
                              roughness_576 = 1.0;
                            } else {
                              diffuseColor_573 = planeColors[idx_581];
                              specularColor_574 = vec3(0.0, 0.0, 0.0);
                              reflectiveColor_575 = vec3(0.0, 0.0, 0.0);
                              roughness_576 = planeRoughness[idx_581];
                            };
                            lowp float tmpvar_621;
                            tmpvar_621 = dot (normal_572, -(tmpvar_567));
                            if ((tmpvar_621 < 0.0)) {
                              normal_572 = -(normal_572);
                            };
                          } else {
                            if ((intersected_582 == 3)) {
                              diffuseColor_573 = (lightIntensity[idx_581] / 25.0);
                              isLight_577 = bool(1);
                            };
                          };
                        };
                        indirectDiffuseColor_562 = diffuseColor_573;
                        indirectSpecularColor_561 = specularColor_574;
                        indirectRefColor_560 = reflectiveColor_575;
                        indirectRoughness_559 = roughness_576;
                        float tmpvar_622;
                        tmpvar_622 = sqrt(dot (reflectiveColor_575, reflectiveColor_575));
                        if ((tmpvar_622 > 0.0)) {
                          indirectDiffuseColor_562 = reflectiveColor_575;
                        };
                        lowp vec3 tmpvar_623;
                        if (isLight_577) {
                          tmpvar_623 = indirectDiffuseColor_562;
                        } else {
                          lowp vec3 point_624;
                          point_624 = position_571;
                          lowp vec3 ray_dir_625;
                          ray_dir_625 = tmpvar_567;
                          lowp vec3 normal_626;
                          normal_626 = normal_572;
                          vec3 diffuseColor_627;
                          diffuseColor_627 = indirectDiffuseColor_562;
                          vec3 specularColor_628;
                          specularColor_628 = specularColor_574;
                          highp int i_629;
                          lowp vec3 illuminationColor_630;
                          i_629 = 0;
                          while (true) {
                            highp int k_631;
                            bool inShade_632;
                            highp int areaShadowSamples_633;
                            lowp vec3 light_sum_634;
                            vec2 lightSpot_635;
                            vec2 lightSize_636;
                            vec3 lightIntensity_637;
                            vec3 lightPos_638;
                            if ((i_629 >= 2)) {
                              break;
                            };
                            if ((i_629 == numLights)) {
                              break;
                            };
                            lightPos_638 = lightPos[i_629];
                            lightIntensity_637 = lightIntensity[i_629];
                            lightSize_636 = lightSize[i_629];
                            lightSpot_635 = lightSpot[i_629];
                            areaShadowSamples_633 = 0;
                            inShade_632 = bool(0);
                            k_631 = 0;
                            while (true) {
                              vec3 testPos_639;
                              if ((k_631 >= 5)) {
                                break;
                              };
                              if (inShade_632) {
                                break;
                              };
                              if ((k_631 == 1)) {
                                break;
                              };
                              testPos_639 = lightPos_638;
                              if ((k_631 == 1)) {
                                testPos_639.x = (lightPos_638.x - (lightSize_636.x * 0.5));
                                testPos_639.z = (lightPos_638.z - (lightSize_636.y * 0.5));
                              } else {
                                if ((k_631 == 2)) {
                                  testPos_639.x = (testPos_639.x + (lightSize_636.x * 0.5));
                                  testPos_639.z = (testPos_639.z + (lightSize_636.y * 0.5));
                                } else {
                                  if ((k_631 == 3)) {
                                    testPos_639.x = (testPos_639.x + (lightSize_636.x * 0.5));
                                    testPos_639.z = (testPos_639.z - (lightSize_636.y * 0.5));
                                  } else {
                                    if ((k_631 == 4)) {
                                      testPos_639.x = (testPos_639.x - (lightSize_636.x * 0.5));
                                      testPos_639.z = (testPos_639.z + (lightSize_636.y * 0.5));
                                    };
                                  };
                                };
                              };
                              lowp vec3 vec_to_light_640;
                              lowp vec3 incident_intensity_641;
                              lowp float spot_falloff_642;
                              vec_to_light_640 = (testPos_639 - point_624);
                              lowp float tmpvar_643;
                              tmpvar_643 = sqrt(dot (vec_to_light_640, vec_to_light_640));
                              lowp float tmpvar_644;
                              tmpvar_644 = (1.0/(((attenuation.x * 
                                (tmpvar_643 * tmpvar_643)
                              ) + (attenuation.y * tmpvar_643))));
                              lowp vec3 tmpvar_645;
                              tmpvar_645 = normalize(vec_to_light_640);
                              vec_to_light_640 = tmpvar_645;
                              spot_falloff_642 = 1.0;
                              if ((lightSpot_635.x > 0.0)) {
                                lowp float tmpvar_646;
                                if ((tmpvar_645.y > lightSpot_635.x)) {
                                  tmpvar_646 = pow (tmpvar_645.y, lightSpot_635.y);
                                } else {
                                  tmpvar_646 = 0.0;
                                };
                                spot_falloff_642 = tmpvar_646;
                              };
                              incident_intensity_641 = ((lightIntensity_637 * tmpvar_644) * spot_falloff_642);
                              lowp float tmpvar_647;
                              tmpvar_647 = sqrt(dot (incident_intensity_641, incident_intensity_641));
                              if ((tmpvar_647 > 0.01)) {
                                lowp vec3 ray_origin_648;
                                ray_origin_648 = point_624;
                                lowp vec3 ray_direction_649;
                                ray_direction_649 = tmpvar_645;
                                lowp float t_hit_650;
                                t_hit_650 = tmpvar_643;
                                bool tmpvar_651;
                                tmpvar_651 = bool(0);
                                highp int i_652;
                                highp int i_653;
                                i_653 = 0;
                                while (true) {
                                  if ((i_653 >= 5)) {
                                    break;
                                  };
                                  if ((i_653 == numSpheres)) {
                                    break;
                                  };
                                  lowp float t_hit_654;
                                  t_hit_654 = t_hit_650;
                                  bool tmpvar_655;
                                  lowp vec3 tmpvar_656;
                                  tmpvar_656 = (sphereCenters[i_653] - ray_origin_648);
                                  lowp float tmpvar_657;
                                  tmpvar_657 = dot (tmpvar_656, ray_direction_649);
                                  if ((tmpvar_657 < 0.0)) {
                                    tmpvar_655 = bool(0);
                                  } else {
                                    lowp float tmpvar_658;
                                    tmpvar_658 = (dot (tmpvar_656, tmpvar_656) - (tmpvar_657 * tmpvar_657));
                                    if ((tmpvar_658 > 0.64)) {
                                      tmpvar_655 = bool(0);
                                    } else {
                                      lowp float tmpvar_659;
                                      tmpvar_659 = sqrt((0.64 - tmpvar_658));
                                      lowp float tmpvar_660;
                                      tmpvar_660 = (tmpvar_657 - tmpvar_659);
                                      lowp float tmpvar_661;
                                      tmpvar_661 = (tmpvar_657 + tmpvar_659);
                                      lowp float tmpvar_662;
                                      if ((tmpvar_660 < 0.01)) {
                                        tmpvar_662 = tmpvar_661;
                                      } else {
                                        tmpvar_662 = tmpvar_660;
                                      };
                                      if (((tmpvar_662 < t_hit_650) && (tmpvar_662 > 0.01))) {
                                        t_hit_654 = tmpvar_662;
                                        tmpvar_655 = bool(1);
                                      } else {
                                        tmpvar_655 = bool(0);
                                      };
                                    };
                                  };
                                  t_hit_650 = t_hit_654;
                                  if (tmpvar_655) {
                                    tmpvar_651 = bool(1);
                                    break;
                                  };
                                  i_653++;
                                };
                                if (!(tmpvar_651)) {
                                  i_652 = 0;
                                  while (true) {
                                    if ((i_652 >= 6)) {
                                      break;
                                    };
                                    if ((i_652 == numPlanes)) {
                                      break;
                                    };
                                    vec3 normal_663;
                                    normal_663 = planeNormals[i_652];
                                    lowp float t_hit_664;
                                    t_hit_664 = t_hit_650;
                                    bool tmpvar_665;
                                    tmpvar_665 = bool(1);
                                    bool tmpvar_666;
                                    vec3 tmpvar_667;
                                    tmpvar_667 = (normal_663 * planeOffsets[i_652]);
                                    lowp float tmpvar_668;
                                    tmpvar_668 = (((
                                      (tmpvar_667.x + tmpvar_667.y)
                                     + tmpvar_667.z) - dot (normal_663, ray_origin_648)) / dot (normal_663, ray_direction_649));
                                    if (((tmpvar_668 < t_hit_650) && (tmpvar_668 > 0.01))) {
                                      t_hit_664 = tmpvar_668;
                                      tmpvar_666 = bool(1);
                                      tmpvar_665 = bool(0);
                                    };
                                    if (tmpvar_665) {
                                      tmpvar_666 = bool(0);
                                      tmpvar_665 = bool(0);
                                    };
                                    t_hit_650 = t_hit_664;
                                    if (tmpvar_666) {
                                      tmpvar_651 = bool(1);
                                      break;
                                    };
                                    i_652++;
                                  };
                                  if (!(tmpvar_651)) {
                                    tmpvar_651 = bool(1);
                                  };
                                };
                                lowp float tmpvar_669;
                                tmpvar_669 = abs((t_hit_650 - tmpvar_643));
                                if ((tmpvar_669 < 0.001)) {
                                  lowp vec3 tmpvar_670;
                                  lowp float tmpvar_671;
                                  tmpvar_671 = dot (normal_626, tmpvar_645);
                                  if ((tmpvar_671 > 0.0)) {
                                    tmpvar_670 = (incident_intensity_641 * ((diffuseColor_627 * 
                                      max (0.0, dot (normal_626, tmpvar_645))
                                    ) + (specularColor_628 * 
                                      pow (max (0.0, dot ((
                                        -(tmpvar_645)
                                       - 
                                        ((2.0 * dot (-(tmpvar_645), normal_626)) * normal_626)
                                      ), -(ray_dir_625))), 32.0)
                                    )));
                                  } else {
                                    tmpvar_670 = vec3(0.0, 0.0, 0.0);
                                  };
                                  light_sum_634 = (light_sum_634 + tmpvar_670);
                                } else {
                                  inShade_632 = bool(1);
                                };
                              } else {
                                inShade_632 = bool(1);
                              };
                              areaShadowSamples_633++;
                              k_631++;
                            };
                            illuminationColor_630 = (illuminationColor_630 + (light_sum_634 / float(areaShadowSamples_633)));
                            i_629++;
                          };
                          tmpvar_623 = illuminationColor_630;
                        };
                        indirect_sampling_sum_557 = (indirect_sampling_sum_557 + tmpvar_623);
                        k_556++;
                      };
                      tmpvar_555 = ((indirect_sampling_sum_557 / float(indirectSamples)) * diffuseColor_398);
                    };
                    mirror_sample_color_386 = (tmpvar_502 + tmpvar_555);
                  } else {
                    mirror_sample_color_386 = (mirror_sample_color_386 + (ambientLight * diffuseColor_398));
                  };
                  reflectionSum_385 = (reflectionSum_385 + (mirror_sample_color_386 * refColor_383));
                  origin_380 = position_396;
                  rayDir_381 = tmpvar_392;
                  refColor_383 = (reflectiveColor_400 * refColor_383);
                };
                pixelColor_5 = (pixelColor_5 + reflectionSum_385);
              };
              lowp vec3 x_672;
              x_672 = (mat3(0.59719, 0.076, 0.0284, 0.35458, 0.90834, 0.13383, 0.04823, 0.01566, 0.83777) * pixelColor_5);
              x_672 = (((x_672 * 
                (x_672 + 0.0245786)
              ) - 9.0537e-05) / ((x_672 * 
                ((0.983729 * x_672) + 0.432951)
              ) + 0.238081));
              x_672 = (mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276, -0.07367, -0.00605, 1.07602) * x_672);
              lowp vec3 tmpvar_673;
              tmpvar_673 = clamp (x_672, 0.0, 1.0);
              pixelColor_5 = tmpvar_673;
              lowp vec3 tmpvar_674;
              tmpvar_674 = pow (tmpvar_673, vec3(0.4545454, 0.4545454, 0.4545454));
              float tmpvar_675;
              if ((tmpvar_673.x < 0.0031308)) {
                tmpvar_675 = 1.0;
              } else {
                tmpvar_675 = 0.0;
              };
              float tmpvar_676;
              if ((tmpvar_673.y < 0.0031308)) {
                tmpvar_676 = 1.0;
              } else {
                tmpvar_676 = 0.0;
              };
              float tmpvar_677;
              if ((tmpvar_673.z < 0.0031308)) {
                tmpvar_677 = 1.0;
              } else {
                tmpvar_677 = 0.0;
              };
              vec3 tmpvar_678;
              tmpvar_678.x = tmpvar_675;
              tmpvar_678.y = tmpvar_676;
              tmpvar_678.z = tmpvar_677;
              lowp vec3 tmpvar_679;
              tmpvar_679 = mix (((tmpvar_674 * 1.055) - 0.055), (tmpvar_673 * 12.92), tmpvar_678);
              pixelColor_5 = tmpvar_679;
              lowp vec4 tmpvar_680;
              tmpvar_680.w = 1.0;
              tmpvar_680.xyz = tmpvar_679;
              fragColor = tmpvar_680;
            }
            
            
        </script>
        <script src="webgl-utils.js"></script>
        <script src='gl-matrix-min.js'></script>
        <script src='world-state.js'></script>
        <script src='raytracer.js'></script>
    </body>
</html>